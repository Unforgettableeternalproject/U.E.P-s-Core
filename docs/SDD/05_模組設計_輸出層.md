# 第五章:模組設計 - 輸出層 (Module Design - Output Layer)

[← 上一章:模組設計 - 處理層](./04_模組設計_處理層.md) | [返回主文件](../SDD.md) | [下一章:展示層架構 →](./06_展示層架構.md)

---

## 5.1 TTS 模組 (Text-to-Speech Module)

**檔案位置**: `modules/tts_module/`  
**職責**: 情感化語音合成、文本分段、串流播放

### 5.1.1 模組架構

```
tts_module/
├── tts_module.py                    # 主模組類
├── __init__.py                      # 註冊函數
├── schemas.py                       # Input/Output Schemas
├── config.yaml                      # 模組配置
│
├── emotion_mapper.py                # 8D 情感映射
├── chunker.py                       # 智能文本分段
├── audio_player.py                  # 音訊播放器
├── producer_consumer.py             # 串流合成管理
│
└── models/                          # IndexTTS 模型
    ├── gpt_model/                   # UnifiedVoice (GPT)
    ├── s2mel_model/                 # CFM (Flow Matching)
    ├── vocoder/                     # BigVGAN
    └── semantic_codec/              # VQ-VAE
```

### 5.1.2 核心技術棧

| 技術組件 | 模型/版本 | 用途 |
|:---|:---|:---|
| **IndexTTS Lite** | Custom Pipeline | E2E 語音合成引擎 |
| **UnifiedVoice (GPT)** | Transformer-based | 語義 Token 生成 |
| **S2Mel (CFM)** | Flow Matching | Mel 頻譜合成 |
| **BigVGAN** | GAN Vocoder | 波形生成 (22050 Hz) |
| **Semantic Codec** | VQ-VAE | 語義編碼/解碼 |
| **EmotionMapper** | Custom | Status Manager → 8D 映射 |
| **TTSChunker** | Rule-based | 智能文本分段 |

### 5.1.3 核心功能

1. **IndexTTS 合成引擎**: GPT→S2Mel→BigVGAN 完整 pipeline
2. **8D 情感向量控制**: 動態情感映射與細緻調整
3. **智能文本分段**: URL/縮寫保護、引號配對檢查
4. **Producer-Consumer 串流**: 邊合成邊播放,降低延遲
5. **Status Manager 整合**: 即時讀取系統情感狀態

### 5.1.4 設計理念

#### 為何採用 IndexTTS 實作？

**IndexTTS 的優勢**:
- **情感細緻控制**: 支援 8 維情感向量獨立調整
- **高音質**: 22050 Hz 採樣率,接近真人語音
- **輕量化**: Lite 版本可本地運行,無需雲端服務
- **原聲保留**: 可控制情感強度,避免過度覆蓋角色音色

#### 為何需要 8D 情感映射？

傳統 TTS 僅支援簡單的「開心/悲傷」情緒,IndexTTS 的 8D 向量提供:
- **複雜情感表達**: 如「高傲地生氣」、「無奈地憂鬱」
- **動態情感**: 每次合成即時從 Status Manager 讀取當前狀態
- **情感漸變**: 透過向量融合實現平滑過渡

### 5.1.5 Input/Output Schemas

```python
@dataclass
class TTSInput(BaseModel):
    """TTS 模組輸入"""
    text: str                           # 輸入文字
    use_emotion: bool = True            # 啟用情感映射
    emotion_strength: float = 0.3       # 情感強度 (0-1)
    speaker_id: Optional[str] = None    # 說話者 ID (多音色支援)
    
@dataclass
class TTSOutput(BaseModel):
    """TTS 模組輸出"""
    success: bool                       # 合成成功
    audio_paths: List[str]              # 音訊檔案路徑
    total_chunks: int                   # 分段數量
    total_duration: float               # 總時長 (秒)
```

### 5.1.6 IndexTTS Pipeline

#### 完整合成流程

```
文本輸入
    ↓
[1] Text Processing
    ├─ TextNormalizer: 文本規範化 (數字→文字)
    ├─ TextTokenizer: BPE 分詞
    └─ Chunking: 切分為 200 tokens/段
    ↓
[2] GPT (UnifiedVoice)
    ├─ 輸入: text_tokens + spk_cond_emb + emo_vec
    ├─ inference_speech(): 生成語義 codes
    └─ 輸出: codes (語義表示)
    ↓
[3] Semantic Codec (VQ-VAE)
    ├─ VQ-VAE 解碼: codes → S_infer
    └─ 與 GPT latent 融合
    ↓
[4] S2Mel (CFM Flow Matching)
    ├─ Length Regulator: 調整時長
    ├─ CFM inference: 生成 Mel 頻譜
    └─ 輸出: mel (80-dim, T frames)
    ↓
[5] BigVGAN (Vocoder)
    ├─ Mel → 波形 (22050 Hz)
    └─ 保存為 .wav
```

#### 關鍵技術細節

| Pipeline 階段 | 輸入 | 輸出 | 耗時 |
|:---|:---|:---|:---|
| Text Processing | 原始文字 | BPE tokens | ~10ms |
| GPT | text_tokens + emo_vec | semantic codes | ~500ms |
| Semantic Codec | codes | S_infer (latent) | ~50ms |
| S2Mel (CFM) | S_infer + text | mel (80×T) | ~800ms |
| BigVGAN | mel | waveform (22050 Hz) | ~300ms |

**總耗時**: ~1.7s/段 (200 tokens)

### 5.1.7 8D 情感向量映射

#### 情感維度定義

```python
emotion_vector = [
    happy,        # 快樂
    angry,        # 生氣
    sad,          # 悲傷
    afraid,       # 恐懼
    disgusted,    # 厭惡
    melancholic,  # 憂鬱
    surprised,    # 驚訝
    calm          # 平靜
]
```

#### Status Manager → 8D 映射邏輯

**輸入參數** (來自 Status Manager):
- `mood`: -1 (負面) ~ +1 (正面)
- `pride`: 0 (低自信) ~ 1 (高傲)
- `helpfulness`: 0 (冷漠) ~ 1 (熱心)
- `boredom`: 0 (興奮) ~ 1 (無聊)

**映射規則**:

| Status 組合 | 情感向量變化 | 語音效果 |
|:---|:---|:---|
| `mood > 0` | `happy ↑`, `surprised ↑`, `calm ↑` | 開朗語調 |
| `mood < 0` | `sad ↑`, `afraid ↑` | 低沉語調 |
| `pride > 0.5` + `mood < 0` | `angry ↑↑`, `sad ↓` | **高傲地生氣** (關鍵創新!) |
| `pride < 0.5` | `melancholic ↑`, `afraid ↑` | 缺乏自信 |
| `helpfulness > 0.5` | `calm ↑` | 溫和語調 |
| `boredom > 0.5` | `melancholic ↑`, `happy ↓` | 無聊疲憊 |

**核心創新 - Pride 的雙向作用**:
```python
# 高傲 + 負面情緒 = 生氣 (有自信地反駁)
if pride > 0.5 and mood < 0:
    angry += (pride - 0.5) * abs(mood) * 0.8
    sad -= (pride - 0.5) * 0.4  # 減少軟弱感

# 低自信 = 憂鬱
elif pride < 0.5:
    melancholic += (0.5 - pride) * 0.4
    afraid += (0.5 - pride) * 0.2
```

#### 原聲保留機制

**max_strength 參數**:
- 預設值: `0.3` (保留 70% 原始音色)
- 情感向量歸一化後縮放至 max_strength
- 避免過度情感化導致音色失真

```python
# 歸一化到 max_strength
emotion_vector = normalize(emotion_vector)  # 總和 = 1
emotion_vector *= max_strength              # 縮放至 0.3
```

### 5.1.8 智能文本分段 (TTSChunker)

#### 設計理念

**為何需要分段？**
- IndexTTS GPT 限制: 單次最多 200 tokens
- 長文本需要切分為多段合成
- 分段點影響語調自然度

#### 分段策略 (優先級排序)

| 優先級 | 分段標記 | 說明 |
|:---|:---|:---|
| **1** | URL/Email 保護 | 替換為 placeholder,避免被切斷 |
| **2** | 縮寫保護 | `e.g.`, `i.e.`, `Mr.`, `Dr.` 不被句點切斷 |
| **3** | 數字保護 | `1,234.56` 不被逗號/句點切割 |
| **4** | 強句界 | `.!?。？!` + 引號/空白 |
| **5** | 次級標點 | `;；:：—、` |
| **6** | 逗號 (避開千分位) | `,` (檢查前後非數字) |
| **7** | 連詞 | `, and`, `, but`, `, however` |
| **8** | 空白 | 最後手段 |
| **9** | 強制切割 | 80% 位置,避開字母數字 |

#### 引號/括號配對檢查

**配對追蹤**:
- 不對稱括號: `()`, `[]`, `【】`, `「」`, `『』`, `《》`
- 對稱引號: `"`, `'` (toggle 狀態追蹤)

**範例**:
```
輸入: "他說:「這很重要!」然後離開了。"
分段:
  1. "他說:「這很重要!」" (引號閉合)
  2. "然後離開了。" (新句開始)
```

### 5.1.9 Producer-Consumer 串流播放

#### 設計理念

**為何使用串流？**
- 降低首次發聲延遲 (TTFS - Time To First Speech)
- 邊合成邊播放,使用者體驗更流暢
- 避免長文本合成完才開始播放

#### 架構設計

```
┌─────────────────────────────────────────┐
│      Producer-Consumer Pipeline          │
├─────────────────────────────────────────┤
│                                         │
│  Producer (合成執行緒)                   │
│    ↓                                    │
│  for chunk in chunks:                  │
│    audio = synthesize(chunk, emo_vec)  │
│    queue.put(audio_path)               │
│                                         │
│  ─────── Queue (maxsize=2) ──────      │
│                                         │
│  Consumer (播放執行緒)                   │
│    ↓                                    │
│  while True:                           │
│    audio_path = queue.get()            │
│    play_audio(audio_path)              │
│    os.remove(audio_path)  # 清理暫存檔 │
│                                         │
└─────────────────────────────────────────┘
```

#### 關鍵參數

| 參數 | 值 | 說明 |
|:---|:---|:---|
| `queue.maxsize` | `2` | 最多緩衝 2 段音訊 |
| `chunk_max_tokens` | `200` | 單段最大 Token 數 |
| `temp_audio_dir` | `outputs/tts/` | 暫存音訊目錄 |

### 5.1.10 配置參數

| 參數 | 預設值 | 說明 |
|:---|:---|:---|
| `sample_rate` | `22050` | 音訊採樣率 (Hz) |
| `emotion_strength` | `0.3` | 情感強度 (0-1) |
| `chunk_max_tokens` | `200` | 分段最大 Token 數 |
| `queue_maxsize` | `2` | 串流佇列大小 |
| `gpt_temperature` | `0.85` | GPT 生成隨機性 |
| `s2mel_steps` | `20` | CFM 採樣步數 |
| `vocoder_denoise` | `0.005` | BigVGAN 降噪強度 |

### 5.1.11 已知問題與改進方向

#### 已知問題
1. **長句合成延遲**: 單段 200 tokens 約需 1.7s,長文本累積延遲明顯
2. **情感過渡生硬**: 相鄰分段情感向量可能差異較大
3. **TTS-STT 串音**: TTS 播放的音訊會觸發 STT VAD

#### 改進方向
- 實作情感向量平滑過渡 (segment-to-segment interpolation)
- 整合 Streaming TTS (逐 token 生成)
- 添加 TTS 播放期間的 STT 抑制機制

---

## 5.2 UI 模組 (User Interface Module)

**檔案位置**: `modules/ui_module/`  
**職責**: 介面中樞、協調 ANI/MOV、前端整合

### 5.2.1 模組架構

```
ui_module/
├── ui_module.py                     # 主模組類 (中樞控制器)
├── __init__.py                      # 註冊函數
├── schemas.py                       # Input/Output Schemas
├── config.yaml                      # 模組配置
│
├── desktop_pet.py                   # 桌面寵物主視窗
├── user_access_widget.py            # 快速存取小工具 (球體)
├── user_main_window.py              # 使用者設定視窗
├── monitoring_window.py             # 監控與狀態視窗
├── debug_interface.py               # 除錯介面
│
└── frontend_adapter.py              # 前端整合適配器 (預留)
```

### 5.2.2 核心技術棧

| 技術組件 | 用途 |
|:---|:---|
| **PyQt5** | GUI 框架 |
| **QWidget** | 視窗組件基類 |
| **QTimer** | 定時器 (16ms 刷新率 ≈ 60 FPS) |
| **QPixmap** | 圖像顯示 |
| **Qt.FramelessWindowHint** | 無邊框視窗 |
| **Qt.WA_TranslucentBackground** | 透明背景 |
| **Qt.WindowStaysOnTopHint** | 桌面最上層 |

### 5.2.3 核心功能

1. **中樞協調**: 整合 ANI/MOV 模組,統一管理前端組件
2. **桌面寵物**: 透明 Overlay,拖拽互動,動畫顯示
3. **快速存取小工具**: 球體狀快速存取入口
4. **使用者設定視窗**: 系統偏好、模組配置管理
5. **監控視窗**: 即時狀態監控、效能指標顯示

### 5.2.4 設計理念

#### 為何採用中樞模式？

**職責分離**:
- **UI Module**: 僅負責視窗協調與顯示,不處理動畫/移動邏輯
- **ANI Module**: 專注動畫片段管理與播放
- **MOV Module**: 專注移動行為與物理模擬

**依賴注入**:
```python
# UI 初始化時主動載入 ANI/MOV
ani_module = debug_api.get_or_load_module("ani")
mov_module = debug_api.get_or_load_module("mov")

# 注入 ANI 到 MOV (讓 MOV 能直接調用動畫)
mov_module.attach_ani(ani_module)

# 創建 Desktop Pet 時傳入模組
desktop_pet = DesktopPetApp(ui_module, ani_module, mov_module)
```

### 5.2.5 介面架構

```
┌────────────────────────────────────────────┐
│           UI Module (中樞控制器)            │
├────────────────────────────────────────────┤
│                                            │
│  ┌──────────────────────────────────────┐ │
│  │   Desktop Pet (桌面寵物 Overlay)      │ │
│  │  • 透明無邊框視窗                      │ │
│  │  • 拖拽互動                            │ │
│  │  • 動畫顯示 (從 ANI 拉取)              │ │
│  │  • 位置同步 (接收 MOV 回呼)            │ │
│  └──────────────────────────────────────┘ │
│                                            │
│  ┌──────────────────────────────────────┐ │
│  │   User Access Widget (快速存取球體)   │ │
│  │  • 桌面右下角浮動球體                  │ │
│  │  • 點擊展開選單                        │ │
│  │  • 快速啟動功能                        │ │
│  └──────────────────────────────────────┘ │
│                                            │
│  ┌──────────────────────────────────────┐ │
│  │   User Main Window (使用者設定)       │ │
│  │  • 系統偏好設定                        │ │
│  │  • 模組配置管理                        │ │
│  │  • 身份管理                            │ │
│  └──────────────────────────────────────┘ │
│                                            │
│  ┌──────────────────────────────────────┐ │
│  │   Monitoring Window (監控視窗)        │ │
│  │  • 即時狀態監控                        │ │
│  │  • 效能指標圖表                        │ │
│  │  • 模組健康檢查                        │ │
│  └──────────────────────────────────────┘ │
│                                            │
└────────────────────────────────────────────┘
```

### 5.2.6 Desktop Pet 整合設計

#### PyQt5 視窗設定

```python
class DesktopPetApp(QWidget):
    def __init__(self, ui_module, ani_module, mov_module):
        super().__init__()
        
        # 透明無邊框視窗
        self.setWindowFlags(
            Qt.FramelessWindowHint |      # 無邊框
            Qt.WindowStaysOnTopHint |     # 最上層
            Qt.Tool                       # 不顯示在工作列
        )
        self.setAttribute(Qt.WA_TranslucentBackground)  # 透明背景
        
        # 註冊 MOV 位置回呼
        mov_module.add_position_callback(self._on_position_changed)
        
        # 定時拉取 ANI 當前幀 (60 FPS)
        self.timer = QTimer()
        self.timer.timeout.connect(self._update_frame)
        self.timer.start(16)  # ~60 FPS
```

#### 動畫顯示流程

```
ANI Module 更新當前幀
    ↓
Desktop Pet 定時拉取 (16ms):
pixmap = ani_module.get_current_frame()
    ↓
顯示在 QLabel:
label.setPixmap(pixmap)
```

#### 位置同步流程

```
MOV Module 計算新位置 (行為邏輯)
    ↓
觸發位置回呼:
position_callback(x, y)
    ↓
Desktop Pet 移動視窗:
self.move(x, y)
```

### 5.2.7 User Access Widget (快速存取球體)

#### 設計理念

**為何需要快速存取？**
- 桌面寵物主要用於視覺互動,不適合頻繁操作
- 球體小工具提供快速功能入口
- 展開式選單避免佔用桌面空間

#### 功能設計

```
球體狀態:
├─ 收合: 小球 (32×32 px)
└─ 展開: 選單 (120×200 px)
    ├─ 開始/停止系統
    ├─ 開啟設定視窗
    ├─ 開啟監控視窗
    └─ 退出程式
```

### 5.2.8 User Main Window (使用者設定)

#### 設定分類

| 分類 | 設定項目 | 說明 |
|:---|:---|:---|
| **系統偏好** | 語言、主題、啟動選項 | 基本系統設定 |
| **模組配置** | STT/TTS/LLM 參數調整 | 模組行為微調 |
| **身份管理** | 使用者檔案、記憶令牌 | 身份與記憶設定 |
| **前端整合** | API 端點、認證設定 | 前端連接配置 (預留) |

### 5.2.9 Monitoring Window (監控視窗)

#### 監控指標

| 指標類型 | 顯示內容 |
|:---|:---|
| **系統狀態** | 當前狀態 (IDLE/CHAT/WORK)、會話 ID |
| **模組健康** | 各模組狀態 (綠/黃/紅)、錯誤計數 |
| **效能指標** | CPU/記憶體使用率、處理延遲 |
| **事件日誌** | 最近事件列表 (Event Bus 歷史) |

### 5.2.10 前端整合橋接器 (Frontend Bridge)

**檔案位置**: `core/frontend_bridge.py`  
**狀態**: ✅ 已完成

#### 設計理念

Frontend Bridge 是展示層的中樞控制器，在 Phase 3 完整實現了前後端一體化整合。

**已實現功能**:
- **統一前端管理**: 管理 UI/MOV/ANI 三模組生命週期
- **事件協調**: 訂閱後端事件並轉換為前端事件
- **ON_CALL 管理**: 處理快速呼叫模式（VAD/文字雙模式）
- **雙模式支援**: 協調器模式（僅前端）與完整模式（含後端整合）

#### 關鍵方法

| 方法 | 功能 |
|:---|:---|
| `initialize()` | 初始化前端模組（協調器/完整雙模式） |
| `_load_frontend_modules()` | 從 Registry 載入前端模組 |
| `start_on_call()` | 啟動 ON_CALL（VAD/文字模式） |
| `end_on_call()` | 結束 ON_CALL |
| `inject_text_input()` | 注入文本輸入到系統 |
| `_handle_state_changed()` | 狀態變更處理 |
| `_handle_session_started()` | 會話開始 |
| `_handle_session_ended()` | 會話結束 |

詳見 [第六章：展示層架構](./06_展示層架構.md) 完整說明。

---

## 5.3 MOV 模組 (Movement Module)

**檔案位置**: `modules/mov_module/`  
**職責**: 桌寵移動控制、行為狀態機、物理模擬

### 5.3.1 模組架構

```
mov_module/
├── mov_module.py                    # 主模組類 (協調器)
├── __init__.py                      # 註冊函數
├── schemas.py                       # Input/Output Schemas
├── config.yaml                      # 模組配置
│
├── physics_engine.py                # 物理引擎 (重力/摩擦)
├── state_machine.py                 # 行為狀態機
├── behaviors/                       # 行為實現
│   ├── idle_behavior.py             # 待機行為
│   ├── movement_behavior.py         # 移動行為
│   ├── special_move_behavior.py    # 特殊動作
│   └── transition_behavior.py      # 模式轉換
│
└── movement_modes.py                # 移動模式定義
```

### 5.3.2 核心技術棧

| 技術組件 | 用途 |
|:---|:---|
| **Physics Engine** | 重力、阻尼、摩擦力模擬 |
| **State Machine** | 行為狀態切換邏輯 |
| **Behavior Factory** | 行為工廠模式 |
| **ANI Module 注入** | 動畫播放控制 |

### 5.3.3 核心功能

1. **物理模擬**: 重力、阻尼、摩擦力計算
2. **行為狀態機**: IDLE/NORMAL_MOVE/SPECIAL_MOVE/TRANSITION 狀態管理
3. **動畫分離**: MOV 不處理圖像,僅觸發 ANI 播放
4. **拖拽互動**: 拖拽檢測與投擲物理
5. **模式切換**: 地面行走 ↔ 浮空漂浮

### 5.3.4 設計理念

#### 為何動畫與移動分離？

**職責清晰**:
- **MOV**: 位置計算、行為邏輯、物理模擬
- **ANI**: 圖像管理、幀播放、動畫元數據

**靈活性**:
- MOV 可獨立測試移動邏輯 (無需圖像資源)
- ANI 可獨立測試動畫播放 (無需物理計算)
- 動畫替換不影響移動邏輯

#### 動畫請求統一入口

```python
def _trigger_anim(self, name: str, params: Dict):
    """統一動畫請求入口"""
    # MOV 決定播放什麼動畫
    # ANI 負責實際播放
    self.ani_module.play(name, **params)
    
    # await_finish 機制
    if params.get("await_finish"):
        self.movement_locked = True  # 鎖定移動
```

### 5.3.5 三層架構設計

```
┌────────────────────────────────────────────┐
│         MOV Module (三層分離架構)           │
├────────────────────────────────────────────┤
│                                            │
│  [Core Layer - 核心層]                     │
│  ├─ Physics Engine: 重力、阻尼、摩擦       │
│  ├─ Position/Velocity: 位置與速度管理      │
│  └─ State Machine: 行為狀態切換邏輯        │
│                                            │
│  [Behavior Layer - 行為層]                 │
│  ├─ IdleBehavior: 待機行為                │
│  ├─ MovementBehavior: 移動行為            │
│  ├─ SpecialMoveBehavior: 特殊動作         │
│  └─ TransitionBehavior: 模式轉換          │
│                                            │
│  [Integration - 整合層]                    │
│  └─ ANI Module 注入:                      │
│      • _trigger_anim(name, params)       │
│      • _on_ani_finish() 回呼             │
│                                            │
└────────────────────────────────────────────┘
```

### 5.3.6 移動模式 (Movement Modes)

| 模式 | 物理特性 | 適用動畫 |
|:---|:---|:---|
| `GROUND` | 貼地行走,受重力與摩擦 | `walk_*_g`, `idle_*_g` |
| `FLOAT` | 浮空漂浮,無重力 | `float_idle_f`, `smile_idle_f` |
| `DRAGGING` | 拖拽中,跟隨滑鼠 | `dragged` |
| `THROWN` | 投擲狀態,拋物線軌跡 | `fly_spin` |

### 5.3.7 行為狀態機

#### 狀態定義

```python
class BehaviorState(Enum):
    IDLE = "idle"                    # 待機 (35-45% 機率)
    NORMAL_MOVE = "normal_move"      # 正常移動 (40-45%)
    SPECIAL_MOVE = "special_move"    # 特殊動作 (10-15%)
    TRANSITION = "transition"        # 模式轉換 (3-5%)
```

#### 狀態轉換圖

```
┌─────────────────────────────────────────┐
│        Behavior State Machine           │
├─────────────────────────────────────────┤
│                                         │
│         ┌───────────┐                  │
│    ┌───→│   IDLE    │←───┐            │
│    │    └───────────┘    │            │
│    │         ↓           │            │
│    │    ┌─────────┐      │            │
│    ├───→│NORMAL   │──────┤            │
│    │    │ MOVE    │      │            │
│    │    └─────────┘      │            │
│    │         ↓           │            │
│    │    ┌─────────┐      │            │
│    └────│SPECIAL  │──────┘            │
│         │ MOVE    │                   │
│         └─────────┘                   │
│              ↕                        │
│         TRANSITION                    │
│   (GROUND ↔ FLOAT)                   │
│                                         │
└─────────────────────────────────────────┘
```

### 5.3.8 物理引擎

#### 物理參數

| 參數 | 預設值 | 說明 |
|:---|:---|:---|
| `gravity` | `980` | 重力加速度 (px/s²) |
| `ground_friction` | `0.8` | 地面摩擦係數 |
| `air_resistance` | `0.95` | 空氣阻力係數 |
| `bounce_damping` | `0.6` | 彈跳阻尼係數 |

#### 物理計算

```python
def update_physics(dt: float):
    """物理更新"""
    if movement_mode == MovementMode.GROUND:
        # 地面模式: 受重力與摩擦
        velocity.y += gravity * dt
        velocity.x *= ground_friction
        
        # 碰撞地面
        if position.y >= ground_y:
            position.y = ground_y
            velocity.y *= -bounce_damping  # 彈跳
    
    elif movement_mode == MovementMode.FLOAT:
        # 浮空模式: 僅空氣阻力
        velocity *= air_resistance
    
    # 更新位置
    position += velocity * dt
```

### 5.3.9 動畫與移動協作

#### await_finish 機制

```python
def _trigger_anim(self, name: str, params: Dict):
    """觸發動畫並可選等待完成"""
    await_finish = params.get("await_finish", False)
    
    if await_finish:
        self.movement_locked = True  # 鎖定移動
        self.pending_anim = name
    
    # 調用 ANI Module
    self.ani_module.play(name, **params)

def _on_ani_finish(self, anim_name: str):
    """ANI 回呼: 動畫完成"""
    if anim_name == self.pending_anim:
        self.movement_locked = False  # 解除鎖定
        self.pending_anim = None
```

#### 轉場動畫範例

```python
class TransitionBehavior(BaseBehavior):
    def on_enter(self, ctx: BehaviorContext):
        if ctx.movement_mode == MovementMode.GROUND:
            # 地面 → 浮空: 起飛動畫
            ctx.trigger_anim("takeoff", {
                "loop": False,
                "await_finish": True,           # 等待動畫完成
                "next_anim": "smile_idle_f",    # 完成後接浮空待機
                "next_params": {"loop": True}
            })
        else:
            # 浮空 → 地面: 降落動畫
            ctx.trigger_anim("landing_g", {
                "loop": False,
                "await_finish": True,
                "next_anim": "stand_idle_g",
                "next_params": {"loop": True}
            })
```

---

## 5.4 ANI 模組 (Animation Module)

**檔案位置**: `modules/ani_module/`  
**職責**: 動畫片段管理、幀播放、狀態追蹤

### 5.4.1 模組架構

```
ani_module/
├── ani_module.py                    # 主模組類
├── __init__.py                      # 註冊函數
├── schemas.py                       # Input/Output Schemas
├── config.yaml                      # 動畫配置 (YAML)
│
├── animation_manager.py             # 動畫管理器
├── animation_clip.py                # 動畫片段元數據
├── frame_cache.py                   # 圖像快取
│
└── animations/                      # 動畫資源
    ├── ground/                      # 地面動畫
    │   ├── walk_left_g/
    │   ├── walk_right_g/
    │   └── stand_idle_g/
    └── float/                       # 浮空動畫
        ├── float_idle_f/
        └── smile_idle_f/
```

### 5.4.2 核心技術棧

| 技術組件 | 用途 |
|:---|:---|
| **AnimationManager** | 動畫播放狀態管理 |
| **QPixmap Cache** | 圖像快取與變換 |
| **OmegaConf** | YAML 配置解析 |
| **Alias Mapping** | 動畫別名映射 |

### 5.4.3 核心功能

1. **動畫片段註冊**: 從 YAML 自動載入動畫元數據
2. **幀序列播放**: 管理當前幀索引與播放狀態
3. **Alias 映射**: MOV 用名 → 實際檔案映射
4. **Transform 快取**: 預計算縮放/偏移變換
5. **Cooldown 防抖**: 避免重複快速觸發相同動畫

### 5.4.4 設計理念

#### 為何配置驅動？

**優勢**:
- 新增動畫僅需修改 YAML,無需改程式碼
- 動畫元數據 (幀數、FPS、縮放) 集中管理
- 便於非開發人員調整動畫參數

#### 為何需要 Alias？

**範例**:
```yaml
aliases:
  turn_left_g: "walk_left_g"    # MOV 使用 turn_left_g
  turn_right_g: "walk_right_g"  # 實際播放 walk_right_g
```

**用途**:
- MOV 的行為邏輯與動畫檔案解耦
- 動畫替換不影響 MOV 程式碼

### 5.4.5 AnimationClip 結構

```python
@dataclass
class AnimationClip:
    """動畫片段元數據"""
    name: str                       # 動畫名稱
    total_frames: int               # 總幀數
    fps: int                        # 播放速率
    default_loop: bool              # 預設是否循環
    zoom: float = 1.0               # 縮放比例
    offset_x: int = 0               # X 偏移
    offset_y: int = 0               # Y 偏移
    frames_dir: str                 # 幀檔案目錄
```

### 5.4.6 動畫觸發流程

```
MOV._trigger_anim("turn_left_g", {loop: False})
    ↓
ANI.play("turn_left_g", loop=False)
    ↓
AnimationManager.play():
    1. 解析 Alias: "turn_left_g" → "walk_left_g"
    2. 檢查 Cooldown (0.25s)
    3. 載入 AnimationClip 元數據
    4. 重置 current_frame = 0
    5. 設定播放狀態 = PLAYING
    ↓
每幀更新 (16ms):
manager.update():
    1. 計算下一幀索引
    2. 從 FrameCache 載入圖像
    3. 應用 Transform (zoom, offset)
    4. 返回 QPixmap
    ↓
播放完成:
_emit_finish("turn_left_g")
    ↓
MOV._on_ani_finish() → 解除鎖定
```

### 5.4.7 Cooldown 防抖機制

**設計理念**:
- 避免短時間內重複觸發相同動畫
- 防止動畫閃爍與狀態混亂

**實作**:
```python
cooldown_duration = 0.25  # 250ms

def play(self, name: str, **params):
    now = time.time()
    last_time = self.last_play_time.get(name, 0)
    
    if now - last_time < cooldown_duration:
        return  # 忽略重複請求
    
    self.last_play_time[name] = now
    # 繼續播放邏輯...
```

### 5.4.8 配置範例 (config.yaml)

```yaml
# 動畫片段定義
clips:
  walk_left_g:
    total_frames: 8
    fps: 12
    default_loop: true
    zoom: 1.0
    offset_x: 0
    offset_y: 0
    frames_dir: "animations/ground/walk_left_g"
  
  smile_idle_f:
    total_frames: 12
    fps: 10
    default_loop: true
    zoom: 1.2
    offset_y: -10
    frames_dir: "animations/float/smile_idle_f"

# 別名映射
aliases:
  turn_left_g: "walk_left_g"
  turn_right_g: "walk_right_g"
```

---

## 總結 (Summary)

本章節說明了輸出層的四個核心模組:

✅ **TTS 模組**:
- IndexTTS Pipeline (GPT→S2Mel→BigVGAN)
- 8D 情感向量映射 (Pride 雙向作用創新)
- 智能文本分段 (TTSChunker)
- Producer-Consumer 串流播放

✅ **UI 模組**:
- 中樞協調模式 (整合 ANI/MOV)
- Desktop Pet (透明 Overlay)
- 使用者工具三視窗（設定/狀態/監控）
- ON_CALL 快速呼叫管理

✅ **MOV 模組**:
- 三層架構 (Core/Behavior/Integration)
- 物理引擎 (重力/摩擦模擬)
- 行為狀態機 (IDLE/MOVE/SPECIAL/TRANSITION)
- 動畫分離設計 (await_finish 機制)

✅ **ANI 模組**:
- 配置驅動動畫註冊 (YAML)
- Alias 映射 (MOV 用名 ↔ 實際檔案)
- Cooldown 防抖機制
- Transform 快取 (縮放/偏移)

這四個模組透過依賴注入與事件回呼緊密協作,實現情感化語音輸出與生動的桌面寵物互動體驗。

---

[← 上一章:模組設計 - 處理層](./04_模組設計_處理層.md) | [返回主文件](../System%20Design%20Documentation.md) | [下一章:展示層架構 →](./06_展示層架構.md)
