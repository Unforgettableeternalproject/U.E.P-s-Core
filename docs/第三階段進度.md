# U.E.P Phase 3 前後端整合與系統優化

---

## 階段概述

Phase 3 是 U.E.P 專案從**後端完備**走向**前後端一體化**的關鍵階段。在 Phase 2 成功完成事件驅動架構重構、六大核心模組標準化、以及完整的會話管理系統後,Phase 3 將聚焦於:

1. **前後端整合** - 實現 UI/MOV/ANI 三大前端模組與核心系統的完整連接
2. **特殊狀態實作** - 完成 MISCHIEF 和 SLEEP 狀態的完整行為設計
3. **VAD 進階優化** - 實現基於意圖的智慧語音觸發機制
4. **工作流強化** - 子工作流、自然語言路徑解析、完整互動體驗
5. **系統監控完善** - 實際效能指標收集與展示
6. **模組結構統一** - 建立一致的模組檔案組織架構

---

## Phase 2 完成度總結

### 核心成就回顧

Phase 2 實現了系統架構的質的飛躍,主要成就包括:

✅ **事件驅動架構轉型** (100% 完成)
- Event Bus 實現 20+ 種系統事件
- 模組間完全解耦,鬆耦合通訊
- 異步事件處理與歷史追蹤

✅ **三層處理模型** (100% 完成)
- Input Layer (STT, NLP)
- Processing Layer (MEM, LLM, SYS)
- Output Layer (TTS, UI)
- Flow-based 去重機制

✅ **六大核心模組重構** (平均 95% 完成)
- **STT**: VAD 整合、Whisper-large-v3、說話人識別 (90%)
- **NLP**: BIOS 意圖分段、身份管理、狀態決策權 (95%)
- **MEM**: 身份隔離記憶、快照系統、FAISS 向量庫 (100%)
- **LLM**: CHAT_MEM/WORK_SYS 協作、Context Caching、MCP Client (95%)
- **TTS**: IndexTTS Lite、情感映射、StatusManager 整合 (90%)
- **SYS**: 工作流引擎、MCP Server、9 類工作流 (100%)

✅ **核心系統架構** (100% 完成)
- General Session (GS) / Chatting Session (CS) / Workflow Session (WS) 三層會話
- Working Context 協作通道 (CHAT_MEM, WORK_SYS)
- Module Coordinator 層級管理與去重
- State Queue Manager 自動狀態推進
- StatusManager 情緒與狀態整合

### 關鍵架構創新

1. **會話-狀態一體化**: 狀態自動創建會話,會話結束觸發狀態轉換
2. **協作通道系統**: LLM 根據系統狀態自動切換 MEM/SYS 協作管道
3. **Flow-based 去重**: `session_id:cycle_index:layer` 鍵值防止重複處理
4. **MCP 協議整合**: 業界標準 tool-calling,LLM-SYS 互動式工作流
5. **身份隔離記憶**: Memory Token 機制,per-user FAISS 索引

### Phase 2 與原始目標對比

根據 `第二階段進度.md` 文檔,Phase 2 的六大目標達成情況:

| 原始目標 | 完成度 | 實際成果 |
|---------|--------|---------|
| 六大核心模組完成重構並標準化 API/Schema | ✅ 100% | 所有模組採用 Pydantic schemas,Event-driven 通訊標準化 |
| 前端（UI/MOV/ANI）雛型能與後端溝通 | ⚠️ 80% | UI 模組框架存在,前端整合文檔完整,實際整合待 Phase 3 |
| 支援 LLM function-calling | ✅ 100% | MCP Server 完整實現,互動式工作流執行 |
| 提供功能完整的 YAML/JSON 規格書與全模組自動化測試 | ✅ 90% | 各模組 config.yaml 完整,測試覆蓋率待提升 |

**總體評分: 96%** ⭐⭐⭐⭐⭐

---

## Phase 3 開發目標

### 目標一: 實作橋接器,實現前後端完整整合

#### 1.1 系統事件與動畫引擎連接

**目標**: UI/MOV/ANI 模組能接收系統事件,作為動畫觸發器

**關鍵任務**:
- [ ] Event Bus 擴充前端專用事件類型
  - `ANIMATION_STATE_CHANGED`: 系統狀態改變 → 動畫切換
  - `EXPRESSION_TRIGGERED`: 情緒表達 → 表情動畫
  - `INTERACTION_REQUIRED`: 需要使用者輸入 → 提示動畫
  - `WORKFLOW_PROGRESS`: 工作流進度 → 進度指示器
  
- [ ] ANI 模組訂閱關鍵事件
  ```python
  # 範例架構
  event_bus.subscribe(SystemEvent.PROCESSING_LAYER_COMPLETE, ani_module.on_processing_complete)
  event_bus.subscribe(SystemEvent.STATE_CHANGED, ani_module.on_state_change)
  event_bus.subscribe(StatusEvent.MOOD_CHANGED, ani_module.on_mood_change)
  ```

- [ ] MOV 模組整合桌面位置管理
  - 接收狀態事件調整角色行為模式
  - 實現 idle/chat/work/error 四種移動模式
  - 支援手動拖曳與碰撞回饋

**驗收標準**:
- 系統狀態改變時,動畫能自動切換 (IDLE → CHAT → WORK)
- TTS 語音播放時,角色有對應的口型動畫
- 工作流執行時,有視覺化進度指示

#### 1.2 動態設定傳入與 UI 控制面板

**目標**: 使用者可透過 UI Gadget 直接控制內部系統運作

**關鍵任務**:
- [ ] 設計 UI Settings API
  - 讀取當前系統設定 (debug_level, log_level, mood 等)
  - 動態更新設定 (無需重啟系統)
  - 設定變更事件發布

- [ ] 實作 User Gadget 功能
  - 系統狀態監控面板 (CPU/Memory/Module Status)
  - 模組效能指標實時顯示
  - 快速設定調整 (VAD 靈敏度、TTS 語速等)
  - 工作流歷史與快照瀏覽器

- [ ] 設定持久化機制
  - 使用者偏好自動儲存至 `configs/user_preferences.yaml`
  - 下次啟動自動載入

**驗收標準**:
- UI 面板能顯示所有模組的即時狀態
- 使用者調整設定後,系統即時響應 (如調整 TTS 語速立即生效)
- 設定在系統重啟後保持

#### 1.3 MOV 模組行為綁定後端狀態

**目標**: 角色行為與實際工作流狀態同步

**關鍵任務**:
- [ ] 實現狀態-行為映射表
  ```yaml
  # 範例: movement_behaviors.yaml
  IDLE:
    movement_pattern: random_walk
    interaction_radius: 50px
    idle_animations: [blink, stretch, look_around]
  
  CHAT:
    movement_pattern: stationary
    face_user: true
    animations: [talking, listening, thinking]
  
  WORK:
    movement_pattern: focused
    busy_indicator: true
    animations: [typing, reading, processing]
  ```

- [ ] 工作流類型專屬動作
  - File workflows → 檔案圖示拖曳動畫
  - Media workflows → 音樂播放視覺效果
  - Reminder workflows → 提醒彈出動畫

- [ ] 錯誤狀態視覺回饋
  - 工作流失敗 → 沮喪表情
  - 網路錯誤 → 困惑動作
  - 使用者取消 → 理解手勢

**驗收標準**:
- 工作流執行時,角色有對應的忙碌動作
- 對話時角色保持面向使用者
- 錯誤發生時有清晰的視覺提示

#### 1.4 前端模組與主程式連動

**目標**: UEP 主桌面應用程式與 User Gadget 資料同步

**關鍵任務**:
- [ ] 設計前端模組間通訊協議
  - UI ↔ MOV: 位置座標同步
  - UI ↔ ANI: 動畫狀態查詢
  - MOV ↔ ANI: 移動觸發動畫

- [ ] 實作統一前端管理器 (Frontend Coordinator)
  - 管理 UI/MOV/ANI 三個模組的生命週期
  - 處理前端模組間事件路由
  - 與 Working Context 整合

- [ ] 前端模組隨系統啟動
  ```python
  # production_runner.py 擴充
  async def initialize_frontend():
      ui_module = await UIModule.initialize()
      mov_module = await MOVModule.initialize()
      ani_module = await ANIModule.initialize()
      frontend_coordinator.register_modules(ui_module, mov_module, ani_module)
  ```

**驗收標準**:
- 系統啟動時前端三模組自動初始化
- User Gadget 設定變更能即時反映到主桌面角色
- 前端模組崩潰不影響後端核心功能

---

### 目標二: 完整實作 MISCHIEF 和 SLEEP 狀態

#### 2.1 MISCHIEF 狀態完整設計

**目標**: 系統根據內部數值自動進入搗蛋模式,有完整行為設計

**關鍵任務**:
- [ ] 定義 MISCHIEF 觸發條件
  ```python
  # StatusManager 擴充
  def check_mischief_trigger(self) -> bool:
      # 條件 1: Boredom 達到閾值 (>80)
      # 條件 2: Pride 在健康範圍 (40-60)
      # 條件 3: 無活動會話 (no active CS/WS)
      # 條件 4: 距離上次 MISCHIEF > 30 分鐘
      return (self.boredom > 80 and 
              40 < self.pride < 60 and
              not self.has_active_session() and
              self.time_since_last_mischief() > 1800)
  ```

- [ ] 設計搗蛋行為庫
  ```yaml
  # mischief_behaviors.yaml
  mild:  # 輕度搗蛋 (Boredom 80-90)
    - move_windows_slightly
    - play_sound_effect
    - change_desktop_wallpaper
    - show_random_joke
  
  moderate:  # 中度搗蛋 (Boredom 90-95)
    - open_random_website
    - trigger_fake_notification
    - cursor_follow_chase
    - desktop_icon_rearrange
  
  intense:  # 強度搗蛋 (Boredom >95)
    - fullscreen_animation
    - keyboard_typing_hijack
    - window_cascade_effect
  ```

- [ ] MISCHIEF 狀態結束條件
  - 隨機事件數限制 (3-7 個事件)
  - 時間限制 (5-15 分鐘)
  - 使用者手動互動 (點擊角色或輸入指令)

- [ ] 使用者設定控制
  ```yaml
  # user_preferences.yaml
  mischief:
    enabled: true
    frequency: normal  # low/normal/high
    intensity: moderate  # mild/moderate/intense
    allowed_behaviors: [move_windows, sound_effects, jokes]  # 白名單
    blocked_behaviors: [keyboard_hijack]  # 黑名單
  ```

**驗收標準**:
- Boredom 達到閾值時自動進入 MISCHIEF 狀態
- 搗蛋行為根據設定強度執行
- 使用者可在 UI 中調整搗蛋頻率與允許行為
- MISCHIEF 狀態不干擾正常會話 (加入狀態佇列)

#### 2.2 SLEEP 狀態完整設計

**目標**: 系統長時間無活動自動休眠,節省資源並快速喚醒

**關鍵任務**:
- [ ] 定義 SLEEP 觸發條件
  ```python
  # StatusManager 擴充
  def check_sleep_trigger(self) -> bool:
      # 條件 1: 無活動時間 > 30 分鐘
      # 條件 2: 無待處理工作流
      # 條件 3: 無背景任務執行中
      return (self.idle_time() > 1800 and
              not self.has_pending_workflows() and
              not background_tasks.has_active())
  ```

- [ ] 資源釋放機制
  ```python
  # 進入 SLEEP 狀態時
  async def enter_sleep_state():
      # 1. 保存當前狀態快照
      state_snapshot = self.save_current_state()
      
      # 2. 卸載重量級模組
      await stt_module.unload_models()  # 卸載 Whisper 模型
      await llm_module.release_cache()  # 釋放 Context Cache
      await mem_module.flush_to_disk()  # 記憶持久化
      
      # 3. 降低 VAD 監聽頻率 (從 16kHz → 8kHz)
      stt_module.set_low_power_mode(True)
      
      # 4. 觸發睡眠動畫
      event_bus.publish(SystemEvent.ENTERING_SLEEP)
  ```

- [ ] 快速喚醒機制
  ```python
  # 檢測到使用者輸入時
  async def wake_from_sleep():
      # 1. 播放喚醒動畫 (可在模組載入時播放)
      event_bus.publish(SystemEvent.WAKING_UP)
      
      # 2. 重新載入模組 (異步並行)
      await asyncio.gather(
          stt_module.reload_models(),
          llm_module.restore_cache(),
          mem_module.load_recent_context()
      )
      
      # 3. 恢復狀態快照
      self.restore_state(state_snapshot)
      
      # 4. 發布喚醒完成事件
      event_bus.publish(SystemEvent.WAKE_COMPLETE)
  ```

- [ ] 睡眠狀態視覺效果
  - 角色進入睡眠動畫 (閉眼、Z字睡眠符號)
  - User Gadget 顯示 "休眠中" 狀態
  - 喚醒過程載入動畫 (伸懶腰、揉眼睛)

**驗收標準**:
- 30 分鐘無活動後自動進入 SLEEP 狀態
- 休眠時記憶體佔用降低至少 50%
- 使用者輸入時在 3 秒內完成喚醒
- 喚醒後系統狀態完整恢復

#### 2.3 特殊狀態與會話系統整合

**關鍵任務**:
- [ ] MISCHIEF/SLEEP 加入 State Queue
  ```python
  # StateQueueManager 處理邏輯
  def process_special_states(self):
      # MISCHIEF/SLEEP 與一般狀態使用相同佇列機制
      # 但優先級較低,不會中斷當前會話
      if self.has_active_session():
          return  # 等待當前會話結束
      
      if self.should_enter_mischief():
          self.queue_state(SystemState.MISCHIEF)
      elif self.should_enter_sleep():
          self.queue_state(SystemState.SLEEP)
  ```

- [ ] 特殊狀態的 GS 處理
  - MISCHIEF: 創建短期 GS,記錄搗蛋事件
  - SLEEP: 不創建 GS,直接標記系統狀態

**驗收標準**:
- MISCHIEF/SLEEP 不會中斷正常對話或工作流
- 特殊狀態在佇列中正確排程
- GS 判斷邏輯正確處理特殊狀態

---

### 目標三: VAD 進階實作 - 智慧語音觸發

#### 3.1 基於意圖的 VAD 啟動機制

**問題分析**:
當前 VAD 在輸入層持續啟用,可能捕捉到不應處理的聲音 (如 Discord 聊天)。

**解決方案**:
- [ ] 雙階段 VAD 啟動
  ```python
  # Phase 1: 低靈敏度持續監聽
  # - 只檢測是否有人聲,不進行完整辨識
  # - 檢測到人聲 → 進入 Phase 2
  
  # Phase 2: 意圖檢測
  # - 進行完整語音辨識
  # - NLP 檢查是否包含 CALL intent
  # - 有 CALL intent → 創建會話
  # - 無 CALL intent → 回到 Phase 1
  ```

- [ ] CALL intent 定義
  ```python
  # NLP 模組擴充
  CALL_KEYWORDS = [
      "UEP", "你好", "幫我", "可以", "請",
      "喂", "嘿", "聽著", "注意"
  ]
  
  def has_call_intent(self, text: str, intents: List[Intent]) -> bool:
      # 方法 1: 關鍵詞匹配
      has_keyword = any(kw in text for kw in CALL_KEYWORDS)
      
      # 方法 2: Intent 標籤包含 CALL
      has_call_label = any(intent.label == "CALL" for intent in intents)
      
      return has_keyword or has_call_label
  ```

- [ ] 情境感知 VAD 調整
  ```python
  # 根據系統狀態動態調整 VAD 行為
  VAD_MODES = {
      SystemState.IDLE: {
          "require_call_intent": True,   # 需要 CALL intent
          "sensitivity": "low"            # 低靈敏度
      },
      SystemState.CHAT: {
          "require_call_intent": False,  # 對話中不需要 CALL
          "sensitivity": "high"           # 高靈敏度
      },
      SystemState.WORK: {
          "require_call_intent": False,  # 工作流中可能需要輸入
          "sensitivity": "medium"
      }
  }
  ```

**驗收標準**:
- IDLE 狀態下,只有包含 CALL intent 的語音會創建會話
- CHAT 狀態下,不需要 CALL intent 即可繼續對話
- Discord 等應用的聲音不會觸發 UEP (可透過音訊來源過濾)

---

### 目標四: 強化現有工作流邏輯與子工作流

#### 4.1 子工作流架構實作

**參考**: `ConditionalStep架構債務.md`

**目標**: 支援工作流內嵌套子工作流,實現複雜任務拆解

**關鍵任務**:
- [ ] 定義子工作流 schema
  ```python
  # workflow_schemas.py 擴充
  class SubWorkflowStep(WorkflowStep):
      type: Literal["sub_workflow"] = "sub_workflow"
      workflow_name: str  # 要調用的子工作流名稱
      inherit_context: bool = True  # 是否繼承父工作流上下文
      on_complete: str = "continue"  # complete/terminate/conditional
  ```

- [ ] 子工作流執行器
  ```python
  # WorkflowEngine 擴充
  async def execute_sub_workflow(self, step: SubWorkflowStep):
      # 1. 創建子 WS (繼承父 WS 的 GS)
      sub_ws = self.create_sub_workflow_session(
          parent_ws=self.current_ws,
          workflow_name=step.workflow_name
      )
      
      # 2. 執行子工作流
      result = await self.execute_workflow(sub_ws)
      
      # 3. 結果傳回父工作流
      self.current_ws.context[f"sub_result_{step.id}"] = result
      
      # 4. 根據 on_complete 決定後續
      return self.handle_completion(step.on_complete, result)
  ```

- [ ] 實際應用場景
  ```yaml
  # 範例: intelligent_archive 工作流
  - step: analyze_files
    type: llm_decision
    
  - step: create_folders  # 子工作流
    type: sub_workflow
    workflow_name: folder_management
    
  - step: move_files
    type: system_action
    depends_on: create_folders
  ```

**驗收標準**:
- 子工作流能正確執行並返回結果
- 子工作流失敗時父工作流能正確處理
- 支援最多 3 層嵌套

#### 4.2 Play Media 工作流完整互動體驗

**目標**: 實現完整的媒體播放控制 (繼續/暫停/下一首/音量)

**關鍵任務**:
- [ ] 媒體播放狀態管理
  ```python
  # 新增 MediaPlaybackState
  class MediaPlaybackState:
      playlist: List[str]
      current_index: int
      is_playing: bool
      volume: float
      playback_mode: Literal["sequential", "shuffle", "repeat"]
  ```

- [ ] 媒體控制指令識別
  ```python
  # NLP 模組擴充
  MEDIA_CONTROL_INTENTS = [
      "pause", "resume", "stop",
      "next", "previous", "skip",
      "volume_up", "volume_down", "mute"
  ]
  ```

- [ ] 背景播放與狀態保持
  ```python
  # SYS 模組 - media_control workflow
  async def handle_media_command(command: str):
      if command == "play":
          # 不結束 WS,保持播放狀態
          self.current_ws.set_persistent(True)
      elif command in ["pause", "resume", "stop"]:
          # 更新狀態但不結束 WS
          self.media_state.update(command)
  ```

- [ ] LLM 回應優化
  ```python
  # 播放中的 LLM 回應應該簡短
  MEDIA_RESPONSE_TEMPLATE = """
  使用者正在聽音樂,你的回應應該:
  1. 非常簡短 (1-2 句話)
  2. 不包含工作流詳細資訊
  3. 自然回應媒體控制請求
  
  範例:
  使用者: "下一首"
  你: "好的,已切換" (不要說 "正在執行 play_media 工作流...")
  """
  ```

**驗收標準**:
- 播放音樂時系統能接受控制指令 (暫停/繼續/下一首)
- 調整音量即時生效
- LLM 回應不包含工作流內部資訊

#### 4.3 自然語言路徑解析

**目標**: 使用者可用自然語言描述檔案路徑,系統智慧解析

**關鍵任務**:
- [ ] 路徑解析工作流
  ```python
  # 新增 path_resolution workflow
  steps:
    1. llm_extract_intent: 從使用者輸入提取路徑意圖
       "桌面上的那個文件" → {location: "desktop", type: "file"}
    
    2. python_search: 在可能位置搜尋
       - 檢查 Desktop/Documents/Downloads
       - 使用檔案修改時間、檔名匹配
    
    3. llm_confirmation: 生成確認訊息
       "找到 3 個可能的檔案,是指 report.pdf 嗎?"
    
    4. user_input: 等待使用者確認
    
    5. conditional: 
       - 確認 → 返回路徑
       - 否定 → 回到步驟 3 顯示其他選項
       - 都不是 → 請使用者提供更多資訊
  ```

- [ ] 路徑候選評分系統
  ```python
  def score_path_candidates(query: str, candidates: List[Path]) -> List[Tuple[Path, float]]:
      scores = []
      for path in candidates:
          score = 0.0
          # 檔名相似度
          score += fuzzy_match(query, path.name) * 0.4
          # 修改時間 (最近的加分)
          score += recency_score(path.stat().st_mtime) * 0.3
          # 常用位置加分
          score += location_preference(path.parent) * 0.2
          # 檔案類型匹配
          score += type_match(query, path.suffix) * 0.1
          scores.append((path, score))
      return sorted(scores, key=lambda x: x[1], reverse=True)
  ```

**驗收標準**:
- "桌面上的文件" 能正確找到最近的桌面檔案
- 多個候選時提供選擇介面
- 找不到時引導使用者提供更多資訊

#### 4.4 強化工作流錯誤處理

**關鍵任務**:
- [ ] 錯誤類型分類
  ```python
  class WorkflowError(Exception):
      error_type: Literal[
          "missing_dependency",  # 缺少必要檔案/工具
          "invalid_input",       # 使用者輸入無效
          "external_service",    # 外部 API 失敗
          "permission_denied",   # 權限不足
          "timeout",             # 執行超時
          "user_cancelled"       # 使用者取消
      ]
      recovery_strategy: Optional[str]
  ```

- [ ] 錯誤恢復策略
  ```python
  ERROR_RECOVERY = {
      "missing_dependency": "retry_with_alternative",
      "invalid_input": "request_clarification",
      "external_service": "retry_with_backoff",
      "permission_denied": "request_elevation",
      "timeout": "ask_continue_or_cancel",
      "user_cancelled": "cleanup_and_exit"
  }
  ```

- [ ] 優雅降級
  ```python
  # 範例: news_summary workflow
  try:
      news = await fetch_from_api()
  except ExternalServiceError:
      # 降級方案: 使用快取的新聞
      news = load_cached_news()
      llm_context.add_note("使用快取新聞 (API 暫時無法使用)")
  ```

**驗收標準**:
- 工作流錯誤時有清晰的錯誤訊息
- 可恢復的錯誤自動重試或提供替代方案
- 使用者取消操作時正確清理資源

---

### 目標五: 完整的系統監控和實際效能指標

#### 5.1 模組效能指標收集

**目標**: 所有模組提供標準化效能指標 API

**關鍵任務**:
- [ ] 定義統一效能指標 schema
  ```python
  # core/schemas.py
  class ModuleMetrics(BaseModel):
      module_name: str
      
      # 通用指標
      total_calls: int
      average_latency_ms: float
      error_rate: float
      memory_usage_mb: float
      
      # 模組特定指標
      custom_metrics: Dict[str, Any]
  ```

- [ ] 各模組實作 get_metrics()
  ```python
  # 範例: STT 模組
  def get_metrics(self) -> ModuleMetrics:
      return ModuleMetrics(
          module_name="STT",
          total_calls=self.stats.total_recognitions,
          average_latency_ms=self.stats.avg_latency,
          error_rate=self.stats.errors / self.stats.total_calls,
          memory_usage_mb=self.get_memory_usage(),
          custom_metrics={
              "vad_triggers": self.stats.vad_triggers,
              "speaker_identifications": self.stats.speaker_ids,
              "whisper_model": "large-v3",
              "average_audio_length_sec": self.stats.avg_audio_length
          }
      )
  ```

- [ ] Framework 自動收集
  ```python
  # core/framework.py 擴充
  async def collect_all_metrics(self) -> Dict[str, ModuleMetrics]:
      metrics = {}
      for module_name, module in self.modules.items():
          if hasattr(module, 'get_metrics'):
              metrics[module_name] = await module.get_metrics()
      return metrics
  ```

**驗收標準**:
- 所有核心模組實作 get_metrics() 方法
- Framework 能收集並彙總所有指標
- 效能資料持久化至 `memory/performance_metrics.json`

#### 5.2 User Gadget 系統狀態頁面

**目標**: 在 UI 中實時顯示系統效能指標

**關鍵任務**:
- [ ] 設計系統狀態 UI
  ```
  ┌─────────────────────────────────────┐
  │ U.E.P 系統狀態                      │
  ├─────────────────────────────────────┤
  │ 核心系統                            │
  │  CPU: ▓▓▓░░░░░ 38%                 │
  │  Memory: ▓▓▓▓▓░░░ 62%              │
  │  Uptime: 2h 34m                     │
  ├─────────────────────────────────────┤
  │ 模組狀態                            │
  │  STT  ✅ 125ms avg │ 245 calls     │
  │  NLP  ✅  89ms avg │ 240 calls     │
  │  MEM  ✅  34ms avg │ 180 calls     │
  │  LLM  ✅ 1.2s  avg │ 120 calls     │
  │  TTS  ✅ 890ms avg │ 115 calls     │
  │  SYS  ✅ 210ms avg │  45 calls     │
  ├─────────────────────────────────────┤
  │ 當前會話                            │
  │  Active GS: gs_20251124_001         │
  │  Type: Chatting Session             │
  │  Duration: 5m 23s                   │
  │  Turn: 8                            │
  └─────────────────────────────────────┘
  ```

- [ ] 實時資料更新
  ```python
  # UI 模組
  async def update_status_panel(self):
      while True:
          metrics = await framework.collect_all_metrics()
          self.status_panel.update(metrics)
          await asyncio.sleep(1)  # 每秒更新
  ```

- [ ] 效能警告
  ```python
  # 超過閾值時顯示警告
  THRESHOLDS = {
      "cpu_usage": 80,        # CPU > 80% 警告
      "memory_usage": 85,     # Memory > 85% 警告
      "module_latency": 2000, # 單模組延遲 > 2s 警告
      "error_rate": 0.05      # 錯誤率 > 5% 警告
  }
  ```

**驗收標準**:
- User Gadget 能顯示實時系統狀態
- 效能指標每秒更新
- 超過閾值時有視覺警告

#### 5.3 Controller 例外管理機制

**目標**: 優雅處理系統級錯誤,防止崩潰

**關鍵任務**:
- [ ] 統一例外處理器
  ```python
  # core/controller.py 擴充
  class ExceptionManager:
      def __init__(self):
          self.error_history = []
          self.recovery_strategies = {}
      
      async def handle_exception(self, error: Exception, context: dict):
          # 1. 記錄錯誤
          self.error_history.append({
              "timestamp": datetime.now(),
              "error_type": type(error).__name__,
              "message": str(error),
              "context": context
          })
          
          # 2. 嘗試恢復
          strategy = self.get_recovery_strategy(error)
          if strategy:
              await strategy.execute()
          
          # 3. 發布錯誤事件
          event_bus.publish(SystemEvent.ERROR_OCCURRED, {
              "error": error,
              "recovered": strategy is not None
          })
  ```

- [ ] 錯誤恢復策略
  ```python
  RECOVERY_STRATEGIES = {
      "ModuleTimeoutError": restart_module,
      "SessionInconsistencyError": force_session_cleanup,
      "MemoryOverflowError": trigger_garbage_collection,
      "EventBusDeadlockError": reset_event_queue,
      "WorkflowStuckError": cancel_workflow_and_notify
  }
  ```

- [ ] 健康檢查機制
  ```python
  # 定期檢查系統健康度
  async def health_check(self):
      issues = []
      
      # 檢查模組響應
      for module in self.modules.values():
          if not await module.ping():
              issues.append(f"{module.name} 無響應")
      
      # 檢查記憶體洩漏
      if self.memory_growth_rate() > THRESHOLD:
          issues.append("疑似記憶體洩漏")
      
      # 檢查 Event Bus 堆積
      if event_bus.queue_size() > 1000:
          issues.append("事件佇列堆積")
      
      if issues:
          await self.handle_health_issues(issues)
  ```

**驗收標準**:
- 模組崩潰時能自動重啟
- 錯誤不會導致整個系統崩潰
- 錯誤歷史記錄可在 UI 中查看

---

### 目標六: 重新構造各個模組的檔案結構

#### 6.1 統一模組結構標準

**目標**: 所有模組採用一致的檔案組織架構

**標準結構**:
```
modules/xxx_module/
├── config.yaml              # 模組配置
├── __init__.py              # 模組初始化與匯出
├── module.py                # 主模組類別
├── schemas.py               # Pydantic schemas
├── README.md                # 模組說明文檔
│
├── core/                    # 核心功能
│   ├── __init__.py
│   ├── engine.py            # 主要引擎邏輯
│   └── handlers.py          # 事件處理器
│
├── services/                # 服務層 (外部 API 調用)
│   ├── __init__.py
│   └── api_client.py
│
├── utils/                   # 工具函數
│   ├── __init__.py
│   └── helpers.py
│
├── models/                  # ML 模型相關 (如果有)
│   ├── __init__.py
│   └── model_loader.py
│
└── tests/                   # 模組測試
    ├── __init__.py
    ├── test_core.py
    └── test_integration.py
```

#### 6.2 各模組重構計劃

**優先級排序**:
1. **高優先級** (Phase 3 初期)
   - [ ] NLP 模組 (檔案最多,最需要整理)
   - [ ] SYS 模組 (工作流檔案分散)
   - [ ] MEM 模組 (已有結構但需微調)

2. **中優先級** (Phase 3 中期)
   - [ ] LLM 模組
   - [ ] STT 模組
   - [ ] TTS 模組

3. **低優先級** (Phase 3 後期)
   - [ ] UI/MOV/ANI 模組 (與前端整合一起重構)

**重構原則**:
- 保持向後相容 (更新 import 路徑)
- 逐步遷移 (不一次性大改)
- 完整測試覆蓋 (重構前後功能一致)

#### 6.3 重構檢查清單

對每個模組執行:
- [ ] 主目錄只保留 config.yaml 和 module.py
- [ ] 子功能移至對應子資料夾 (core/services/utils)
- [ ] 更新所有 import 語句
- [ ] 執行測試確保功能正常
- [ ] 更新模組 README.md
- [ ] 提交 git commit (獨立 PR)

---

## Phase 3 驗收標準

### 核心驗收項目

#### 前後端整合驗收
- [ ] **UI 模組啟動**: 系統啟動時前端三模組 (UI/MOV/ANI) 自動初始化
- [ ] **事件驅動動畫**: 系統狀態改變時動畫自動切換 (IDLE→CHAT→WORK)
- [ ] **設定即時生效**: User Gadget 調整設定後系統立即響應
- [ ] **動作狀態同步**: 工作流執行時角色有對應忙碌動作
- [ ] **前端模組通訊**: UI ↔ MOV ↔ ANI 資料正確同步

#### 特殊狀態驗收
- [ ] **MISCHIEF 觸發**: Boredom 達閾值自動進入搗蛋模式
- [ ] **搗蛋行為執行**: 根據使用者設定執行對應強度搣蛋行為
- [ ] **SLEEP 觸發**: 30 分鐘無活動自動休眠
- [ ] **資源釋放**: 休眠時記憶體佔用降低 ≥50%
- [ ] **快速喚醒**: 3 秒內完成喚醒並恢復狀態
- [ ] **狀態佇列整合**: MISCHIEF/SLEEP 不中斷正常會話

#### VAD 進階驗收
- [ ] **意圖觸發**: IDLE 狀態只有 CALL intent 才創建會話
- [ ] **對話持續**: CHAT 狀態下無需 CALL intent 繼續對話
- [ ] **降低誤觸發**: Discord 等應用聲音不觸發 UEP

#### 工作流強化驗收
- [ ] **子工作流執行**: 支援 3 層嵌套子工作流
- [ ] **媒體完整控制**: 播放/暫停/繼續/下一首/音量調整正常
- [ ] **路徑智慧解析**: "桌面上的文件" 能找到正確檔案
- [ ] **錯誤優雅處理**: 工作流錯誤時有清晰訊息與恢復策略
- [ ] **LLM 回應優化**: 播放媒體時回應簡短不含內部資訊

#### 系統監控驗收
- [ ] **效能指標收集**: 所有模組實作 get_metrics()
- [ ] **狀態面板顯示**: User Gadget 顯示實時系統狀態
- [ ] **效能警告**: 超過閾值時顯示視覺警告
- [ ] **例外自動恢復**: 模組崩潰能自動重啟
- [ ] **健康檢查**: 定期檢查並報告系統健康度

#### 模組結構驗收
- [ ] **標準結構**: 所有核心模組符合統一結構標準
- [ ] **文檔完整**: 每個模組有完整 README.md
- [ ] **測試覆蓋**: 重構後功能測試通過率 100%
- [ ] **Import 正確**: 所有 import 路徑更新並可正常運作

### 完整性驗收 (End-to-End)

#### 場景 1: 日常對話與搣蛋
```
1. 系統啟動 → UI/MOV/ANI 模組正常初始化
2. 桌面角色顯示 IDLE 動畫
3. 使用者說 "UEP 你好" → 系統進入 CHAT 狀態
4. 角色切換到對話動畫
5. 對話 5 輪後結束 → 回到 IDLE
6. 等待 20 分鐘 (加速測試) → Boredom 上升
7. Boredom 達閾值 → 自動進入 MISCHIEF
8. 角色執行搗蛋行為 (如移動視窗)
9. 使用者點擊角色 → MISCHIEF 結束,回到 IDLE
```

#### 場景 2: 工作流與休眠喚醒
```
1. 使用者拖放檔案到角色 → 進入 WORK 狀態
2. 角色顯示忙碌動畫
3. 工作流執行 (智慧歸檔)
   - 子工作流: 資料夾創建
   - 主工作流: 檔案移動
4. 完成後回到 IDLE
5. 等待 30 分鐘 (加速測試) → 自動進入 SLEEP
6. 角色顯示睡眠動畫,記憶體降低
7. 使用者輸入 "喂醒醒" → 播放喚醒動畫
8. 3 秒內完成模組重載 → 進入 CHAT 狀態
9. 系統狀態完整恢復
```

#### 場景 3: 媒體控制完整體驗
```
1. 使用者: "播放音樂"
2. 系統進入 WORK 狀態 (play_media)
3. 開始播放,但 WS 保持活動狀態
4. 使用者: "暫停" → 播放暫停,WS 仍活躍
5. 使用者: "下一首" → 切換歌曲,LLM 簡短回應 "好的"
6. 使用者: "音量調大" → 音量上升
7. 播放中間使用者問: "今天天氣如何?"
8. 系統創建新 CS 回答天氣,播放持續
9. 使用者: "停止播放" → WS 結束,回到 IDLE
```

---

## Phase 3 開發時程規劃

### 階段劃分 (預估 3-4 個月)

#### 第一階段: 基礎整合 (4-6 週)
**Week 1-2: 事件系統擴充**
- Event Bus 新增前端事件類型
- 前端模組訂閱機制實作
- Working Context 前端通道建立

**Week 3-4: UI 基礎連接**
- Frontend Coordinator 實作
- 系統狀態面板開發
- 效能指標收集 API

**Week 5-6: MOV/ANI 初步整合**
- 狀態-動畫映射實作
- 基礎移動行為實現
- 動畫切換測試

#### 第二階段: 特殊狀態與 VAD (3-4 週)
**Week 7-8: MISCHIEF 狀態**
- 觸發條件實作
- 搗蛋行為庫開發
- 使用者設定介面

**Week 9-10: SLEEP 狀態**
- 資源釋放機制
- 快速喚醒實作
- 休眠動畫整合

**Week 11: VAD 進階**
- 雙階段 VAD 實作
- CALL intent 檢測
- 情境感知調整

#### 第三階段: 工作流強化 (3-4 週)
**Week 12-13: 子工作流**
- Schema 設計與實作
- 執行器開發
- 嵌套測試

**Week 14: 媒體控制**
- 狀態保持機制
- 控制指令處理
- LLM 回應優化

**Week 15: 路徑解析**
- 自然語言路徑工作流
- 候選評分系統
- 確認介面

#### 第四階段: 監控與重構 (2-3 週)
**Week 16: 系統監控**
- 效能指標完善
- User Gadget 狀態頁面
- 例外管理機制

**Week 17-18: 模組重構**
- NLP/SYS/MEM 重構
- 其他模組整理
- 測試更新

#### 第五階段: 整合測試與優化 (2-3 週)
**Week 19-20: 端到端測試**
- 場景測試設計
- 自動化測試腳本
- Bug 修復

**Week 21: 效能優化**
- 瓶頸分析
- 記憶體優化
- 響應速度提升

---

## 技術債務清理計劃

### Phase 2 遺留問題

1. **Router 角色弱化**
   - 現狀: Router 在事件驅動架構中角色已降低
   - 計劃: Phase 3 評估是否完全移除或轉為輕量級路由

2. **完整端到端測試缺失**
   - 現狀: 關鍵整合點已測試,但缺少完整流程測試
   - 計劃: Phase 3 初期補充 STT→TTS 端到端測試

3. **API 文檔不完整**
   - 現狀: 代碼文檔完整,但缺少自動生成 API 文檔
   - 計劃: Phase 3 中期使用 Sphinx 生成完整文檔

4. **效能基準未建立**
   - 現狀: 有效能監控但缺少基準線
   - 計劃: Phase 3 建立各模組效能基準與回歸測試

### Phase 3 需注意的技術債務

1. **前端穩定性**
   - 前端三模組為新開發,需特別注意穩定性
   - 建議: 初期頻繁測試,快速迭代

2. **特殊狀態複雜度**
   - MISCHIEF/SLEEP 增加狀態機複雜度
   - 建議: 完整狀態轉換圖與測試覆蓋

3. **子工作流性能**
   - 多層嵌套可能影響效能
   - 建議: 限制嵌套深度,監控執行時間

---

## 風險評估與應對

### 高風險項目

| 風險項目 | 影響 | 機率 | 應對策略 |
|---------|------|------|----------|
| 前端整合複雜度超預期 | 高 | 中 | 分階段整合,先 UI 後 MOV/ANI |
| 特殊狀態影響系統穩定性 | 高 | 低 | 完整測試,可配置開關 |
| 子工作流增加除錯難度 | 中 | 中 | 詳細日誌,視覺化工具 |
| 效能監控影響效能 | 中 | 低 | 採樣監控,可關閉選項 |

### 中風險項目

| 風險項目 | 影響 | 機率 | 應對策略 |
|---------|------|------|----------|
| VAD 誤觸發率上升 | 中 | 中 | 可調靈敏度,白名單機制 |
| 模組重構引入 bug | 中 | 中 | 完整測試,逐步遷移 |
| User Gadget 效能問題 | 低 | 中 | 降低更新頻率,懶加載 |

---

## 成功標準

### 量化指標

- **前端整合度**: UI/MOV/ANI 三模組完全整合,事件驅動動畫響應率 ≥95%
- **特殊狀態穩定性**: MISCHIEF/SLEEP 狀態轉換無錯誤,資源釋放效果 ≥50%
- **VAD 準確率**: CALL intent 檢測準確率 ≥90%,誤觸發率 ≤5%
- **工作流完整性**: 子工作流支援 3 層嵌套,錯誤恢復率 ≥80%
- **系統監控覆蓋**: 6 大模組效能指標收集率 100%,UI 展示延遲 ≤1s
- **模組結構一致性**: 9 個核心模組結構統一率 100%

### 質化指標

- **使用者體驗**: 前端互動流暢自然,動畫切換無延遲感
- **系統穩定性**: 連續運行 24 小時無崩潰
- **可維護性**: 新增功能時模組結構清晰易懂
- **可擴展性**: 新增前端模組或工作流無需修改核心架構

---

## 總結

Phase 3 是 U.E.P 從**技術完備**走向**產品化**的關鍵階段。在 Phase 2 建立的堅實架構基礎上,Phase 3 將實現:

1. **完整的前後端一體化** - 使用者能看到、觸摸到的 AI 助理
2. **豐富的互動體驗** - MISCHIEF 搗蛋、SLEEP 休眠、智慧 VAD
3. **強大的工作流能力** - 子工作流、自然語言解析、完整媒體控制
4. **專業的系統監控** - 實時效能指標、健康檢查、自動恢復
5. **一致的代碼品質** - 統一模組結構、完整測試、清晰文檔

完成 Phase 3 後,U.E.P 將具備:
- ✅ 完整的桌面寵物視覺呈現
- ✅ 自然的語音互動體驗
- ✅ 智慧的工作流自動化
- ✅ 穩定的長期運行能力
- ✅ 專業的監控與維護工具

**Phase 3 預計完成時間**: 3-4 個月  
**Phase 4 準備**: 多平台適配、公開測試、產品發布

---

**文件版本**: 1.0  
**撰寫日期**: 2025-11-24  
**維護者**: Bernie  
**最後更新**: 2025-11-24  

**參考文件**:
- [第二階段進度.md](./第二階段進度.md) - Phase 2 原始計劃
- [前後端整合-需求規格.md](../hidden_docs/前後端整合-需求規格.md) - Phase 3 需求
- [SDD.md](./SDD.md) - 系統設計文件
- [本學期的專案進度.md](./本學期的專案進度.md) - 整體專案進度

---

**備註**: 本文件根據 Phase 2 實際完成情況、現有系統架構、以及 Phase 3 需求規格綜合撰寫。所有技術方案均基於現有架構設計,確保可行性與一致性。
