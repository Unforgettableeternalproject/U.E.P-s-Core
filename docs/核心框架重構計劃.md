# UEP Core Framework 重構計劃

## 概述

將現有的 Working Context、State Manager 和 Router 系統整合為一個統一的、可擴展的核心框架，實現模組間的網狀通信架構。

## 現狀分析

### 已實現的核心組件

1. **Working Context Manager** (`core/working_context.py`)
   - ✅ 上下文生命週期管理
   - ✅ 決策處理器協議 (DecisionHandler)
   - ✅ 異步決策機制
   - ✅ 實際應用：STT 語者識別系統

2. **State Manager** (`core/state_manager.py`) 
   - ✅ UEP 狀態管理 (IDLE, CHAT, WORK, ERROR)
   - ✅ 工作流會話管理
   - ⚠️ 與 Working Context 尚未整合

3. **Router** (`core/router.py`)
   - ✅ 意圖到模組的路由
   - ✅ 工作流狀態追蹤
   - ⚠️ 靜態路由表，缺乏動態決策

4. **Session Manager** (`core/session_manager.py`)
   - ✅ 多步驟工作流管理
   - ⚠️ 僅用於 SYS 模組，未與核心框架整合

### 核心問題

1. **模組間通信仍為線性結構**：STT → NLP → MEM/LLM → TTS → SYS
2. **狀態管理分散**：Working Context、State Manager、Session Manager 各自獨立
3. **路由決策缺乏智能性**：基於固定規則，無法根據上下文動態調整
4. **框架擴展性不足**：新增模組需要修改多個核心組件

## 重構目標

### 1. 統一狀態管理系統
- 整合 Working Context、State Manager 和 Session Manager
- 實現全局狀態一致性
- 支援狀態之間的智能轉換

### 2. 智能路由決策系統  
- 從固定路由表轉向動態路由決策
- 根據當前狀態、上下文和模組可用性進行路由
- 支援模組間的並行和條件執行

### 3. 可擴展框架架構
- 模組註冊和發現機制
- 統一的模組通信協議
- 插件式決策處理器

### 4. 網狀通信模式
- 模組間可直接通信
- 基於需求的動態模組調用
- 支援複雜的執行流程

## 技術架構

### 核心組件關係圖

```
┌───────────────────────────────────────────────────────────────┐
│                     Core Framework                            │
├───────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐   ┌──────────────┐  │
│  │   State Engine  │  │  Router Engine  │   │Context Engine│  │
│  │                 │  │                 │   │              │  │
│  │ - UEP States    │  │ - Dynamic Route │   │ - Working    │  │
│  │ - Transitions   │  │ - Smart Routing │   │   Context    │  │
│  │ - Workflows     │  │ - Dependencies  │   │ - Decision   │  │
│  └─────────────────┘  └─────────────────┘   │   Handlers   │  │
│           │                     │           └──────────────┘  │
│           └─────────────────────┼─────────────────────────────┤
│                                 │                             │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │              Module Registry                            │  │
│  │                                                         │  │
│  │  STT ◄──► NLP ◄──► MEM ◄──► LLM ◄──► TTS ◄──► SYS       │  │
│  │   │        │        │        │        │        │        │  │
│  │   └────────┼────────┼────────┼────────┼────────┘        │  │
│  │            └────────┼────────┼────────┘                 │  │
│  │                     └────────┘                          │  │
│  └─────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────┘
```

### 實現步驟

1. **創建 CoreFramework 主類**
2. **實現 StateEngine (統一狀態管理)**
3. **實現 RouterEngine (智能路由)**
4. **實現 ContextEngine (上下文管理)**
5. **重構現有模組以適配新框架**

## 模組 Schema 重構計劃

### 當前問題
- 各模組使用不同的數據格式和 Schema
- 需要 DataTransformer 進行格式轉換
- 模組間通信複雜度高

### 重構策略

#### 統一數據 Schema
```python
# 統一的模組輸入/輸出格式
class UnifiedModuleData(BaseModel):
    # 核心數據
    text: Optional[str] = None
    intent: Optional[str] = None
    context: Optional[Dict[str, Any]] = None
    
    # 模組間傳遞的metadata
    metadata: Dict[str, Any] = Field(default_factory=dict)
    
    # 執行控制
    execution_mode: Optional[str] = None
    priority: Optional[int] = None
    
    # 模組特定數據 (靈活擴展)
    module_data: Dict[str, Any] = Field(default_factory=dict)
```

#### 模組重構優先級
1. **NLP 模組** - 作為管道起點，統一意圖分類格式
2. **MEM 模組** - 統一記憶查詢和儲存格式
3. **LLM 模組** - 統一對話和指令處理格式
4. **TTS 模組** - 統一語音合成請求格式
5. **STT 模組** - 統一語音識別輸出格式

#### 向後兼容策略
- 保留現有 Schema 作為 legacy 支援
- 新 Schema 作為主要介面
- 在模組內部進行格式適配

## 控制器架構重構

### 舊架構問題
- `core/controller.py` 更像調試工具而非控制器
- 混合了業務邏輯和測試代碼
- 缺乏清晰的職責分離

### 新架構設計

#### 1. 調試功能分離
- **devtools/debug_api.py** - 承載所有調試和測試功能
- **core/controller.py** - 作為實際的系統控制器

#### 2. 職責重新分配
```python
# 新的架構職責分配

core/controller.py:
- 系統初始化和生命週期管理
- 模組註冊和協調
- 事件處理和狀態管理
- 決策引擎協調

devtools/debug_api.py:
- 模組功能測試
- 性能監控和統計
- 開發調試工具
- 系統診斷功能

core/framework.py:
- 執行引擎和管道處理
- 路由決策和模組調度
- 數據轉換協調
```

## 預期效益

1. **更好的擴展性**：
   - 統一 Schema 降低新模組集成複雜度
   - 新模組可以輕鬆集成，無需修改核心代碼
   - 清晰的架構職責分離

2. **更智能的決策**：
   - 基於上下文的動態路由和狀態轉換
   - 統一數據格式提升決策準確性

3. **更高的靈活性**：
   - 支援複雜的執行流程和模組間協作
   - 統一 Schema 支援更靈活的數據流

4. **更好的維護性**：
   - 統一的架構和清晰的職責分離
   - 調試功能與業務邏輯分離
   - 代碼組織更加合理
