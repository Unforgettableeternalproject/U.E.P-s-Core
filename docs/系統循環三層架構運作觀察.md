# 系統循環三層架構運作觀察報告

**生成日期：** 2025-10-26  
**分析範圍：** 輸入層 → 處理層 → 輸出層完整循環  
**追蹤目標：** 事件流、Router、Module Coordinator、協作管道機制

---

## 📊 執行摘要

本報告詳細追蹤了 U.E.P 系統的完整處理循環，從使用者輸入到系統輸出的整個流程。重點觀察了三層架構的事件驅動機制、Router 的路由邏輯、Module Coordinator 的協調機制，以及 LLM 模組的協作管道啟用流程。

### 關鍵發現

✅ **運作正常的部分：**
1. 三層架構的事件驅動流程完整且清晰
2. LLM 模組能夠根據系統狀態自主啟用協作管道
3. Router 正確實現了狀態感知的路由邏輯
4. Module Coordinator 的去重機制使用 flow-based 策略有效防止重複處理

⚠️ **發現的問題：**
1. **SYS 模組未註冊資料提供者** - LLM 無法獲取真實工作流狀態
2. **Module Coordinator 與協作管道脫鉤** - 調用前未驗證管道狀態
3. **協作管道生命週期管理不明確** - 缺少明確的啟用/停用時機

---

## 🔄 完整系統循環流程

### 階段 0: 系統啟動與初始化

```
Entry.py
  └─> SystemLoop.start()
      ├─> EventBus.start()              # 啟動事件總線
      ├─> verify_system_ready()         # 驗證組件就緒
      │   ├─> Framework.is_initialized
      │   ├─> Controller.is_initialized
      │   ├─> StateManager.get_current_state() == IDLE
      │   └─> 檢查 ['stt', 'nlp'] 模組存在
      └─> start_stt_listening()         # 啟動語音監聽 (VAD 模式)
          或 start_text_input()         # 啟動文字輸入 (Text 模式)
```

**重要細節：**
- SystemLoop 初始化時 `cycle_index = 0`（用於 flow-based 去重）
- EventBus 訂閱關係已建立：
  - `SystemLoop` 訂閱 `OUTPUT_LAYER_COMPLETE`
  - `ModuleCoordinator` 訂閱 `INPUT_LAYER_COMPLETE`, `PROCESSING_LAYER_COMPLETE`, `CYCLE_COMPLETED`, `SESSION_ENDED`

---

### 階段 1: 輸入層 (INPUT LAYER)

#### 1.1 語音/文字輸入接收

```
使用者輸入 (語音/文字)
  └─> STT Module.handle()
      ├─> 語音識別 / 文字接收
      ├─> 產生 STT result
      └─> 轉發到 NLP 模組
```

**STT 模組職責：**
- 持續監聽（VAD 模式）或等待文字輸入（Text 模式）
- 將語音轉文字或直接接收文字
- **不處理狀態邏輯**，純粹的輸入轉發

#### 1.2 NLP 處理與狀態管理

```
NLP Module.handle(stt_result)
  ├─> 1. 獲取當前狀態: current_state = state_manager.get_current_state()
  ├─> 2. 意圖識別 (使用訓練好的 NLP 模型)
  │   ├─> primary_intent: chat/command/work
  │   ├─> intent_segments: 細分的意圖片段
  │   └─> entities: 提取的實體
  │
  ├─> 3. 狀態管理決策
  │   ├─> 如果 current_state == IDLE:
  │   │   ├─> primary_intent == "chat" → 設定 CHAT 狀態
  │   │   └─> primary_intent == "command/work" → 設定 WORK 狀態
  │   │
  │   ├─> 如果 current_state == CHAT:
  │   │   └─> 檢查是否需要切換到 WORK
  │   │
  │   └─> 如果 current_state == WORK:
  │       └─> 保持 WORK 或根據工作流需求調整
  │
  ├─> 4. 身份識別與 Working Context 設定
  │   ├─> working_context_manager.set_current_identity(identity_data)
  │   └─> working_context_manager.set_context_type(CHAT/WORK)
  │
  ├─> 5. 創建對應會話 (透過 State Manager)
  │   ├─> CHAT 狀態 → 創建 Chatting Session (CS)
  │   └─> WORK 狀態 → 創建 Workflow Session (WS)
  │
  └─> 6. 發布 INPUT_LAYER_COMPLETE 事件
      └─> EventBus.publish(
              event_type=SystemEvent.INPUT_LAYER_COMPLETE,
              data={
                  'session_id': current_gs.session_id,  # General Session ID
                  'cycle_index': SystemLoop.cycle_index,  # 當前循環編號
                  'nlp_result': {...},                   # NLP 分析結果
                  'input_data': {'text': user_text},
                  'timestamp': time.time()
              }
          )
```

**關鍵觀察：**

1. **NLP 是狀態管理的主導者**
   - 決定何時從 IDLE 切換到 CHAT/WORK
   - 負責創建對應的會話（CS/WS）
   - Router 不參與狀態決策，只根據現有狀態路由

2. **會話架構分層**
   ```
   General Session (GS) - 系統級會話，跨越整個對話生命週期
       ├─> Chatting Session (CS) - CHAT 狀態下的對話會話
       └─> Workflow Session (WS) - WORK 狀態下的工作流會話
   ```

3. **Flow-based 去重機制開始生效**
   - `dedupe_key = f"{session_id}:{cycle_index}:INPUT"`
   - ModuleCoordinator 記錄此 dedupe_key，防止重複處理

---

### 階段 2: 處理層轉換 (INPUT → PROCESSING)

#### 2.1 Module Coordinator 接收事件

```
ModuleCoordinator._on_input_layer_complete(event)
  ├─> 1. 提取 flow 識別資訊
  │   ├─> session_id = event.data['session_id']        # GS ID
  │   └─> cycle_index = event.data['cycle_index']
  │
  ├─> 2. Flow-based 去重檢查
  │   ├─> dedupe_key = f"{session_id}:{cycle_index}:INPUT"
  │   ├─> 如果 dedupe_key 已存在 → 跳過處理 (防止重複)
  │   └─> 否則記錄 dedupe_key 並繼續
  │
  └─> 3. 調用層級轉換
      └─> handle_layer_completion(ProcessingLayer.INPUT, event.data)
          └─> _transition_to_processing_layer(input_data)
```

#### 2.2 Router 決策處理層目標

```
ModuleCoordinator._transition_to_processing_layer(input_data)
  ├─> 1. 準備路由輸入
  │   ├─> nlp_result = input_data['nlp_result']
  │   └─> user_text = input_data['input_data']['text']
  │
  ├─> 2. 調用 Router 決策
  │   └─> routing_decision = router.route_user_input(
  │           text=user_text,
  │           source_module="input_layer"
  │       )
  │
  ├─> 3. Router 內部邏輯
  │   ├─> current_state = state_manager.get_current_state()
  │   ├─> 根據狀態查表：
  │   │   ├─> CHAT → primary: "llm", secondary: ["mem"]
  │   │   └─> WORK → primary: "sys", secondary: ["llm"]
  │   └─> 返回 TextRoutingDecision(target_module="llm" or "sys")
  │
  └─> 4. 準備處理層調用請求
      └─> _prepare_processing_requests(target_module, input_data)
          ├─> 如果 primary_intent == "chat":
          │   ├─> ModuleInvocationRequest(target="mem", priority=4)
          │   └─> ModuleInvocationRequest(target="llm", priority=3)
          │
          └─> 如果 primary_intent == "command/work":
              ├─> ModuleInvocationRequest(target="llm", priority=4)
              └─> ModuleInvocationRequest(target="sys", priority=3)
```

**重要發現：**

❌ **問題 1: Module Coordinator 不驗證協作管道狀態**

```python
# 當前實現（module_coordinator.py line 471-496）
def _transition_to_processing_layer(self, input_data):
    # 直接調用 Router，不檢查協作管道是否就緒
    routing_decision = router.route_user_input(...)
    
    # 準備並執行模組調用
    requests = self._prepare_processing_requests(...)
    responses = self.invoke_multiple_modules(requests)
    # ❌ 沒有確保 LLM 的協作管道已啟用
```

**影響：**
- LLM 可能在協作管道尚未啟用時被調用
- 雖然 LLM.handle() 會自己啟用管道，但缺少系統級的狀態驗證
- 理論上可能存在時序問題（狀態切換與模組調用不同步）

---

### 階段 3: 處理層執行 (PROCESSING LAYER)

#### 3.1 LLM Module 處理流程（CHAT 模式為例）

```
LLM Module.handle(data)
  ├─> 1. 解析輸入
  │   └─> llm_input = LLMInput(**data)
  │
  ├─> 2. 獲取當前系統狀態
  │   └─> current_state = state_manager.get_current_state()
  │
  ├─> 3. ✅ 更新協作管道（核心機制）
  │   └─> _update_collaboration_channels(current_state)
  │       ├─> old_status = module_interface.get_channel_status()
  │       ├─> set_collaboration_state(current_state)
  │       │   ├─> 如果 'CHAT' in state_str:
  │       │   │   └─> state_aware_interface.set_channel_active(CHAT_MEM, True)
  │       │   │       └─> _active_channels[CHAT_MEM] = True
  │       │   │
  │       │   └─> 如果 'WORK' in state_str:
  │       │       └─> state_aware_interface.set_channel_active(WORK_SYS, True)
  │       │           └─> _active_channels[WORK_SYS] = True
  │       │
  │       └─> new_status = module_interface.get_channel_status()
  │
  ├─> 4. 會話架構驗證
  │   └─> _validate_session_architecture(current_state)
  │       ├─> 檢查是否有對應的會話 (CS/WS)
  │       └─> 如果無會話 → 返回錯誤，拒絕處理
  │
  ├─> 5. 根據模式處理
  │   ├─> 如果 llm_input.mode == CHAT:
  │   │   └─> _handle_chat_mode(llm_input, status)
  │   │       ├─> 5.1 檢查 CHAT_MEM 管道是否啟用
  │   │       │   └─> if not module_interface.is_channel_active(CHAT_MEM):
  │   │       │       └─> 跳過記憶檢索
  │   │       │
  │   │       ├─> 5.2 如果管道已啟用，檢索相關記憶
  │   │       │   └─> relevant_memories = module_interface.get_chat_mem_data(
  │   │       │           data_type="memory_retrieval",
  │   │       │           query=llm_input.text,
  │   │       │           max_results=5
  │   │       │       )
  │   │       │
  │   │       ├─> 5.3 構建 CHAT 提示（整合記憶）
  │   │       ├─> 5.4 調用 Gemini API 生成回應
  │   │       └─> 5.5 儲存對話到 MEM (透過 CHAT_MEM 管道)
  │   │
  │   └─> 如果 llm_input.mode == WORK:
  │       └─> _handle_work_mode(llm_input, status)
  │           ├─> 5.1 檢查 WORK_SYS 管道是否啟用
  │           │   └─> if not module_interface.is_channel_active(WORK_SYS):
  │           │       └─> 跳過 SYS 資料查詢
  │           │
  │           ├─> 5.2 如果管道已啟用，獲取工作流狀態
  │           │   └─> workflow_status = module_interface.get_work_sys_data(
  │           │           data_type="workflow_status",
  │           │           workflow_id=current_workflow_id
  │           │       )
  │           │
  │           ├─> 5.3 獲取可用功能列表
  │           │   └─> function_registry = module_interface.get_work_sys_data(
  │           │           data_type="function_registry",
  │           │           category="all"
  │           │       )
  │           │
  │           ├─> 5.4 構建 WORK 提示（整合工作流上下文）
  │           ├─> 5.5 調用 Gemini API 生成回應
  │           └─> 5.6 可能調用 MCP Tools 執行系統操作
  │
  └─> 6. 發布 PROCESSING_LAYER_COMPLETE 事件
      └─> _notify_processing_layer_completion(result)
          └─> EventBus.publish(
                  event_type=SystemEvent.PROCESSING_LAYER_COMPLETE,
                  data={
                      'session_id': current_gs.session_id,
                      'cycle_index': SystemLoop.cycle_index,
                      'response': llm_output.text,
                      'processing_time': ...,
                      'timestamp': time.time()
                  }
              )
```

**關鍵發現：**

✅ **LLM 協作管道機制運作正常**

```python
# modules/llm_module/llm_module.py (line 105-115)
def _update_collaboration_channels(self, new_state: UEPState):
    """根據系統狀態更新協作管道"""
    old_status = self.module_interface.get_channel_status()
    set_collaboration_state(new_state)  # 調用 module_interfaces.py 的輔助函數
    new_status = self.module_interface.get_channel_status()
    
    if old_status != new_status:
        debug_log(2, f"[LLM] 協作管道更新: {old_status} → {new_status}")
```

```python
# modules/llm_module/module_interfaces.py (line 201-214)
def set_collaboration_state(system_state: Union[str, Any]):
    """根據系統狀態設定協作管道"""
    # 重設所有管道
    state_aware_interface.set_channel_active(CollaborationChannel.CHAT_MEM, False)
    state_aware_interface.set_channel_active(CollaborationChannel.WORK_SYS, False)
    
    # 根據系統狀態啟用對應管道
    state_str = str(system_state).upper()
    if 'CHAT' in state_str:
        state_aware_interface.set_channel_active(CollaborationChannel.CHAT_MEM, True)
    elif 'WORK' in state_str:
        state_aware_interface.set_channel_active(CollaborationChannel.WORK_SYS, True)
```

**設計評價：**
- ✅ **正確的責任分配** - LLM 自主判斷並啟用協作管道，不依賴外部設定
- ✅ **狀態感知** - 根據 state_manager 的當前狀態動態調整
- ✅ **防護機制** - 管道未啟用時自動跳過資料查詢，避免錯誤

---

❌ **問題 2: SYS 模組未註冊真實資料提供者**

```python
# 當前實現（modules/llm_module/module_interfaces.py line 216-225）
def register_mock_providers():
    """註冊模擬資料提供者，供開發測試使用"""
    # CHAT-MEM 協作管道
    state_aware_interface.register_chat_mem_provider("memory_retrieval", _mock_memory_retrieval)
    state_aware_interface.register_chat_mem_provider("conversation_storage", _mock_conversation_storage)
    
    # WORK-SYS 協作管道 - ❌ 只有 MOCK 提供者
    state_aware_interface.register_work_sys_provider("workflow_status", _mock_workflow_status)
    state_aware_interface.register_work_sys_provider("function_registry", _mock_function_registry)

# ❌ SYS 模組從未調用 register_work_sys_provider
```

**影響：**
```python
# LLM 在 WORK 模式下查詢資料
workflow_status = module_interface.get_work_sys_data(
    data_type="workflow_status",
    workflow_id="ws_123"
)
# 返回模擬數據而非真實工作流狀態：
# {
#     "workflow_id": "default",  # ❌ 不是實際的 ws_123
#     "current_step": "data_analysis",  # ❌ 假數據
#     "progress": 0.65,  # ❌ 假進度
#     ...
# }
```

**真實場景問題：**
1. LLM 無法知道當前工作流真實進度
2. 無法根據實際工作流狀態調整回應
3. MCP Tools 調用可能基於錯誤的假設
4. **WORK 模式的 LLM-SYS 協作實際上無效**

---

#### 3.2 SYS Module 處理流程（WORK 模式下被調用）

```
SYS Module.handle(data)
  ├─> 1. 判斷操作模式
  │   ├─> mode == "start_workflow" → 啟動新工作流
  │   ├─> mode == "continue_workflow" → 繼續執行工作流
  │   └─> mode == "workflow_execution" → 執行特定工作流步驟
  │
  ├─> 2. 工作流引擎執行
  │   ├─> workflow_engine.process_input(user_input)
  │   ├─> 根據 workflow_mode 決定執行方式：
  │   │   ├─> DIRECT → 同步執行，等待完成
  │   │   └─> BACKGROUND → 提交到 BackgroundWorker
  │   │
  │   └─> 返回執行結果
  │       ├─> status: "success" (DIRECT) 或 "submitted" (BACKGROUND)
  │       └─> 包含工作流狀態、進度等資訊
  │
  └─> 3. ❌ 未發布 PROCESSING_LAYER_COMPLETE 事件
      └─> 只有 LLM 會發布此事件，SYS 不會
```

**觀察：**
- SYS 模組通常與 LLM 配合使用
- 在 WORK 模式下，LLM 可能透過 MCP Tools 調用 SYS
- SYS 直接處理時不會觸發處理層完成事件（由 LLM 統一處理）

---

### 階段 4: 輸出層轉換 (PROCESSING → OUTPUT)

#### 4.1 Module Coordinator 接收處理層完成事件

```
ModuleCoordinator._on_processing_layer_complete(event)
  ├─> 1. Flow-based 去重檢查
  │   ├─> dedupe_key = f"{session_id}:{cycle_index}:PROCESSING"
  │   ├─> 如果已處理 → 跳過
  │   └─> 否則記錄並繼續
  │
  └─> 2. 調用層級轉換
      └─> handle_layer_completion(ProcessingLayer.PROCESSING, event.data)
          └─> _transition_to_output_layer(processing_data)
```

#### 4.2 Router 決策輸出層目標

```
ModuleCoordinator._transition_to_output_layer(processing_data)
  ├─> 1. 提取回應文字
  │   └─> response_text = _extract_response_text(processing_data)
  │       ├─> 優先順序: response > text > content
  │       └─> 支援嵌套結構 (llm_output.result.data.text)
  │
  ├─> 2. 過濾表情符號（防止 TTS 錯誤）
  │   └─> routing_decision = router.route_system_output(
  │           text=response_text,
  │           source_module="processing_layer"
  │       )
  │       └─> Router._filter_emojis(response_text)
  │           └─> emoji_pattern.sub('', text)
  │
  ├─> 3. 準備輸出層調用
  │   └─> output_request = ModuleInvocationRequest(
  │           target_module="tts",
  │           input_data={
  │               "text": filtered_text,
  │               "source": "three_layer_coordinator",
  │               ...
  │           }
  │       )
  │
  └─> 4. 執行輸出層調用
      └─> response = invoke_module(output_request)
```

**Router 表情符號過濾機制：**
```python
# core/router.py (line 71-91)
self.emoji_pattern = re.compile(
    "["
    "\U0001F600-\U0001F64F"  # emoticons
    "\U0001F300-\U0001F5FF"  # symbols & pictographs
    "\U0001F680-\U0001F6FF"  # transport & map symbols
    # ... 更多 Unicode 範圍
    "]+", 
    flags=re.UNICODE
)
```

---

### 階段 5: 輸出層執行 (OUTPUT LAYER)

```
TTS Module.handle(data)
  ├─> 1. 文字轉語音處理
  │   ├─> 使用 IndexTTS 引擎
  │   ├─> 生成音頻檔案
  │   └─> 播放音頻
  │
  ├─> 2. 發布 OUTPUT_LAYER_COMPLETE 事件
  │   └─> EventBus.publish(
  │           event_type=SystemEvent.OUTPUT_LAYER_COMPLETE,
  │           data={
  │               'session_id': current_gs.session_id,
  │               'cycle_index': SystemLoop.cycle_index,
  │               'text': tts_input.text,
  │               'audio_file': output_path,
  │               'timestamp': time.time()
  │           }
  │       )
  │
  └─> 3. 返回處理結果
      └─> {"success": True, "text": ..., "audio_file": ...}
```

---

### 階段 6: 循環完成與清理

#### 6.1 SystemLoop 接收輸出層完成事件

```
SystemLoop._on_output_layer_complete(event)
  ├─> 1. 記錄完整流程完成
  │   └─> handle_output_completion(event.data)
  │       └─> _complete_cycle()
  │           ├─> 計算 cycle_time
  │           ├─> 發布 CYCLE_COMPLETED 事件
  │           │   └─> EventBus.publish(
  │           │           event_type=SystemEvent.CYCLE_COMPLETED,
  │           │           data={
  │           │               'session_id': gs_id,
  │           │               'cycle_index': self.cycle_index,
  │           │               'timestamp': time.time()
  │           │           }
  │           │       )
  │           └─> 重置週期追蹤
  │
  ├─> 2. 重新啟動 STT 監聽（VAD 模式）
  │   └─> if input_mode == "vad":
  │       └─> _restart_stt_listening()
  │
  └─> 3. 檢查 GS 結束條件
      └─> _check_cycle_end_conditions()
          └─> unified_controller.check_gs_end_conditions()
```

#### 6.2 Module Coordinator 清理去重鍵

```
ModuleCoordinator._on_cycle_completed(event)
  ├─> 1. 構建 flow 前綴
  │   └─> flow_prefix = f"{session_id}:{cycle_index}:"
  │
  ├─> 2. 清理此循環的所有 layer 鍵
  │   └─> keys_to_remove = [k for k in dedupe_keys if k.startswith(flow_prefix)]
  │       ├─> 例如：["gs_001:5:INPUT", "gs_001:5:PROCESSING"]
  │       └─> 從 dedupe_keys 集合移除
  │
  └─> 3. 更新統計
      ├─> cleanup_count += len(keys_to_remove)
      └─> 記錄清理日誌
```

**去重鍵生命週期：**
```
循環開始: cycle_index = 5
  ├─> INPUT 層: 添加 "gs_001:5:INPUT"
  ├─> PROCESSING 層: 添加 "gs_001:5:PROCESSING"
  └─> OUTPUT 層: 不添加去重鍵（TTS 不經過 Coordinator）

循環結束: CYCLE_COMPLETED 事件
  └─> 清理 "gs_001:5:*" 的所有鍵
      └─> 防止集合無限增長
```

---

## 🎯 事件驅動架構完整鏈路

```
STT 接收輸入
    ↓
NLP 處理與狀態管理
    ↓
EventBus.publish(INPUT_LAYER_COMPLETE) ←┐
    ↓                                    │
ModuleCoordinator 監聽事件               │ 事件訂閱
    ↓                                    │
Router 決策 → 調用 LLM/SYS               │
    ↓                                    │
LLM 啟用協作管道 → 處理請求              │
    ↓                                    │
EventBus.publish(PROCESSING_LAYER_COMPLETE) ←┤
    ↓                                    │
ModuleCoordinator 監聽事件               │
    ↓                                    │
Router 決策 → 調用 TTS                   │
    ↓                                    │
TTS 語音輸出                             │
    ↓                                    │
EventBus.publish(OUTPUT_LAYER_COMPLETE) ←┤
    ↓                                    │
SystemLoop 監聽事件                      │
    ↓                                    │
EventBus.publish(CYCLE_COMPLETED) ←┐    │
    ↓                              │    │
ModuleCoordinator 清理去重鍵        │    │
    ↓                              │    │
系統回到 IDLE 狀態                  │    │
    ↓                              │    │
重新啟動 STT 監聽                   └────┘
```

**事件總線訂閱關係：**
```
EventBus
  ├─> INPUT_LAYER_COMPLETE
  │   └─> ModuleCoordinator._on_input_layer_complete
  │
  ├─> PROCESSING_LAYER_COMPLETE
  │   └─> ModuleCoordinator._on_processing_layer_complete
  │
  ├─> OUTPUT_LAYER_COMPLETE
  │   └─> SystemLoop._on_output_layer_complete
  │
  ├─> CYCLE_COMPLETED
  │   └─> ModuleCoordinator._on_cycle_completed
  │
  └─> SESSION_ENDED
      └─> ModuleCoordinator._on_session_ended
```

---

## ⚙️ 協作管道機制詳解

### 管道類型與用途

```
CollaborationChannel (Enum)
  ├─> CHAT_MEM = "chat_mem"    # CHAT 狀態下的 LLM-MEM 協作
  └─> WORK_SYS = "work_sys"    # WORK 狀態下的 LLM-SYS 協作
```

### 管道狀態流轉

```
系統啟動: 所有管道 = False
    ↓
NLP 判斷意圖 → 設定 CHAT 狀態
    ↓
Module Coordinator 調用 LLM
    ↓
LLM.handle() 被調用
    ↓
LLM._update_collaboration_channels(CHAT)
    ├─> set_collaboration_state(CHAT)
    │   └─> state_aware_interface.set_channel_active(CHAT_MEM, True)
    │       └─> _active_channels[CHAT_MEM] = True
    │
    └─> CHAT_MEM 管道啟用 ✅

LLM 處理過程中查詢記憶
    ↓
module_interface.get_chat_mem_data("memory_retrieval", ...)
    ├─> 檢查: is_channel_active(CHAT_MEM) → True ✅
    ├─> 調用: _chat_mem_providers["memory_retrieval"]
    └─> 返回: 相關記憶數據

循環結束，系統回到 IDLE
    ↓
下次調用 LLM 時會重新判斷狀態
```

### 資料提供者註冊機制

```
StateAwareModuleInterface
  ├─> _chat_mem_providers: Dict[str, Callable]
  │   ├─> "memory_retrieval" → _mock_memory_retrieval  ✅ (模擬)
  │   └─> "conversation_storage" → _mock_conversation_storage  ✅ (模擬)
  │
  └─> _work_sys_providers: Dict[str, Callable]
      ├─> "workflow_status" → _mock_workflow_status  ⚠️ (模擬)
      └─> "function_registry" → _mock_function_registry  ⚠️ (模擬)
```

**註冊流程：**
```python
# 正確的註冊方式（MEM 模組應該這樣做）
state_aware_interface.register_chat_mem_provider(
    data_type="memory_retrieval",
    provider_func=lambda **kwargs: mem_module.search_memory(**kwargs)
)

# ❌ SYS 模組缺少這一步
# state_aware_interface.register_work_sys_provider(
#     data_type="workflow_status",
#     provider_func=lambda **kwargs: sys_module.get_workflow_status(**kwargs)
# )
```

---

## 🐛 發現的問題與分析

### 問題 1: SYS 模組未註冊真實資料提供者

**嚴重程度：** 🔴 HIGH

**問題描述：**
- SYS 模組從未調用 `state_aware_interface.register_work_sys_provider()`
- LLM 在 WORK 模式下只能獲取模擬數據
- **實際影響：** WORK 模式的 LLM-SYS 協作完全無效

**根本原因：**
```python
# modules/llm_module/module_interfaces.py
# 文件末尾自動載入模擬提供者
register_mock_providers()  # ← 開發期間的臨時方案

# ❌ SYS 模組 (modules/sys_module/sys_module.py) 應該在初始化時註冊，但沒有
class SYSModule(BaseModule):
    def initialize(self):
        # ❌ 缺少這些註冊
        # state_aware_interface.register_work_sys_provider(...)
        pass
```

**修復建議：**
```python
# modules/sys_module/sys_module.py
def initialize(self):
    # 註冊 WORK_SYS 協作管道的資料提供者
    from modules.llm_module.module_interfaces import state_aware_interface
    
    # 1. 註冊工作流狀態提供者
    state_aware_interface.register_work_sys_provider(
        data_type="workflow_status",
        provider_func=self._provide_workflow_status
    )
    
    # 2. 註冊功能列表提供者
    state_aware_interface.register_work_sys_provider(
        data_type="function_registry",
        provider_func=self._provide_function_registry
    )
    
    info_log("[SYS] 已註冊 WORK_SYS 協作管道資料提供者")

def _provide_workflow_status(self, **kwargs) -> Dict[str, Any]:
    """提供當前工作流狀態"""
    workflow_id = kwargs.get('workflow_id')
    session = self.session_manager.get_workflow_session(workflow_id)
    if not session:
        return {"status": "not_found", "workflow_id": workflow_id}
    
    engine = self.workflow_engines.get(workflow_id)
    if not engine:
        return {"status": "no_engine", "workflow_id": workflow_id}
    
    return {
        "workflow_id": workflow_id,
        "workflow_type": engine.definition.workflow_type,
        "current_step": engine.get_current_step().id if engine.get_current_step() else None,
        "progress": session.progress,
        "status": session.status.value,
        "available_functions": self._get_available_functions_for_workflow(engine)
    }

def _provide_function_registry(self, **kwargs) -> List[str]:
    """提供可用的系統功能列表"""
    category = kwargs.get('category', 'all')
    
    # 從 functions.yaml 讀取可用功能
    specs = self._load_function_specs()
    if category == 'all':
        return list(specs.keys())
    else:
        # 根據分類過濾
        return [name for name, spec in specs.items() 
                if spec.get('category') == category]
```

---

### 問題 2: Module Coordinator 不驗證協作管道狀態

**嚴重程度：** 🟡 MEDIUM

**問題描述：**
- Module Coordinator 調用 LLM 前不檢查協作管道是否就緒
- 雖然 LLM 自己會啟用管道，但缺少系統級驗證
- 理論上可能存在時序問題（狀態切換與模組調用不同步）

**當前流程：**
```
ModuleCoordinator
  └─> invoke_module(LLM)
      └─> LLM.handle()
          └─> _update_collaboration_channels()  # 此時才啟用管道
```

**潛在風險：**
1. **狀態不一致**：StateManager 的狀態與協作管道狀態可能短暫不同步
2. **缺少防護**：如果 LLM._update_collaboration_channels() 失敗，沒有上層檢測
3. **日誌不完整**：Coordinator 無法記錄管道狀態變化

**修復建議（可選）：**
```python
# core/module_coordinator.py
def invoke_module(self, request: ModuleInvocationRequest):
    # 在調用 LLM 前記錄管道狀態（診斷用）
    if request.target_module == "llm":
        from modules.llm_module.module_interfaces import state_aware_interface
        channel_status = state_aware_interface.get_channel_status()
        debug_log(3, f"[ModuleCoordinator] 調用 LLM 前管道狀態: {channel_status}")
    
    # 正常調用模組
    result = target_module.handle(request.input_data)
    
    # 調用後再次檢查（驗證 LLM 是否正確啟用管道）
    if request.target_module == "llm":
        new_channel_status = state_aware_interface.get_channel_status()
        if channel_status != new_channel_status:
            debug_log(2, f"[ModuleCoordinator] LLM 調用後管道狀態變化: {channel_status} → {new_channel_status}")
```

**評估：**
- 這個問題優先級較低，因為 LLM 的自我管理機制已經足夠
- 主要是缺少系統級的可見性和診斷能力
- 不影響功能正確性，僅影響可維護性

---

### 問題 3: 協作管道生命週期管理不明確

**嚴重程度：** 🟢 LOW

**問題描述：**
- 管道啟用後何時停用不明確
- 每次 LLM.handle() 都會重新設定管道狀態（先全部關閉，再根據狀態啟用）
- 這種設計雖然安全，但可能不夠高效

**當前行為：**
```python
# 每次 LLM 處理都執行
def set_collaboration_state(system_state):
    # 1. 先關閉所有管道
    state_aware_interface.set_channel_active(CHAT_MEM, False)
    state_aware_interface.set_channel_active(WORK_SYS, False)
    
    # 2. 根據狀態啟用
    if 'CHAT' in state_str:
        state_aware_interface.set_channel_active(CHAT_MEM, True)
    elif 'WORK' in state_str:
        state_aware_interface.set_channel_active(WORK_SYS, True)
```

**優點：**
- ✅ 確保狀態一致性
- ✅ 避免管道殘留
- ✅ 簡單明確

**缺點：**
- ⚠️ 每次調用都重複操作
- ⚠️ 無法持久化管道狀態

**評估：**
- 當前設計合理，不需要修改
- 管道狀態應該與系統狀態緊密綁定，每次重新設定是安全的
- 性能影響可忽略（只是簡單的布林值設定）

---

## 📝 建議與改進方向

### 優先級 1: 修復 SYS 資料提供者註冊 🔴

**行動項目：**
1. 在 `SYSModule.initialize()` 中註冊 `workflow_status` 和 `function_registry` 提供者
2. 實現 `_provide_workflow_status()` 和 `_provide_function_registry()` 方法
3. 移除或注釋 `module_interfaces.py` 中的 `register_mock_providers()` 自動載入
4. 測試 WORK 模式下 LLM 能否正確獲取 SYS 資料

**預期效果：**
- LLM 在 WORK 模式下能獲取真實工作流狀態
- 工作流引導和任務分解更準確
- MCP Tools 調用基於正確的上下文

---

### 優先級 2: 增強 Module Coordinator 的管道狀態可見性 🟡

**行動項目：**
1. 在 Coordinator 調用 LLM 前後記錄管道狀態
2. 添加管道狀態變化的日誌
3. 在 `get_invocation_stats()` 中包含管道狀態統計

**預期效果：**
- 更好的系統診斷能力
- 更容易追蹤管道相關問題
- 不影響功能，純粹提升可維護性

---

### 優先級 3: MEM 模組也需要註冊資料提供者 🟡

**行動項目：**
1. 檢查 MEM 模組是否也在使用模擬提供者
2. 如果是，按照 SYS 的方式註冊真實提供者
3. 測試 CHAT 模式下記憶檢索是否正常

**預期效果：**
- 完整的協作管道機制生效
- CHAT 模式下記憶整合更準確

---

## 📊 系統循環性能指標

### 關鍵指標

1. **循環計數 (Loop Count)**
   - 定義：主循環迭代次數（每 0.1 秒一次）
   - 用途：系統活躍度監控

2. **處理週期 (Cycle Index)**
   - 定義：完整的輸入→處理→輸出流程次數
   - 用途：flow-based 去重的核心識別碼

3. **去重鍵數量 (Dedupe Keys)**
   - 定義：`_layer_dedupe_keys` 集合大小
   - 用途：記憶體使用監控
   - 清理機制：CYCLE_COMPLETED 事件觸發清理

4. **事件發布延遲**
   - 定義：事件發布到監聽器接收的時間差
   - 用途：評估事件總線性能

### 效能快照機制

```
SystemLoop._collect_performance_snapshot()  # 每 5 秒
  └─> Framework.collect_system_performance_snapshot()
      ├─> 活躍模組數量
      ├─> 系統成功率
      ├─> 平均響應時間
      └─> 各模組詳細統計
```

---

## 🔍 總結

### 系統設計優點

✅ **事件驅動架構清晰**
- 三層架構的事件流完整且易於追蹤
- EventBus 提供了良好的解耦

✅ **協作管道機制設計良好**
- LLM 自主判斷和啟用管道，責任分配正確
- 狀態感知的資料查詢，避免了硬編碼依賴

✅ **去重機制健全**
- Flow-based 策略有效防止重複處理
- 自動清理機制防止記憶體洩漏

✅ **Router 職責明確**
- 純文字路由，不處理複雜邏輯
- 狀態感知的路由決策

### 主要問題

🔴 **Critical:**
- SYS 模組未註冊真實資料提供者，導致 WORK 模式協作失效

🟡 **Important:**
- Module Coordinator 缺少管道狀態驗證和可見性
- 需要確認 MEM 模組的提供者註冊狀態

🟢 **Optional:**
- 管道生命週期管理可以更精細化（當前設計已足夠）

---

**報告完成日期：** 2025-10-26  
**建議審閱者：** 專案維護者  
**下一步行動：** 根據優先級修復 SYS 資料提供者註冊問題
