# 第一章：系統架構 (System Architecture)

[← 返回主文件](../System%20Design%20Documentation.md)

---

## 1.1 系統架構概覽 (System Architecture Overview)

U.E.P 系統採用**模組化三層事件驅動架構**，透過中央 Event Bus 實現鬆耦合的模組通訊。

### 1.1.1 整體架構圖 (System Architecture Diagram)

```
┌─────────────────────────────────────────────────────────────────────┐
│                         使用者 (User)                                │
└────────────┬────────────────────────────────────────────┬───────────┘
             │ 語音輸入                                    │ 視覺輸出
             ↓                                            ↑
┌────────────────────────────────────────────────────────────────────┐
│                      前端整合層 (Frontend Layer)                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐             │
│  │  UI Module   │  │ ANI Module   │  │  MOV Module  │             │
│  │ (桌面寵物)    │  │ (動畫控制)    │  │ (移動控制)    │             │
│  └──────────────┘  └──────────────┘  └──────────────┘             │
└────────────┬────────────────────────────────────────────┬───────────┘
             │                                            ↑
             │ Frontend Bridge (✅ 已完成)            │
             ↓                                            ↑
┌─────────────────────────────────────────────────────────────────────┐
│                    核心控制層 (Core Control Layer)                   │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    Event Bus (事件匯流排)                     │   │
│  │  • INPUT_LAYER_COMPLETE   • PROCESSING_LAYER_COMPLETE       │   │
│  │  • OUTPUT_LAYER_COMPLETE  • CYCLE_COMPLETED                 │   │
│  │  • WORKFLOW_STEP_COMPLETED • SESSION_ENDED                  │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌───────────┐  ┌──────────────┐  ┌─────────────┐  ┌──────────┐  │
│  │Controller │  │  Framework   │  │   Router    │  │  States  │  │
│  │  (GS管理) │  │ (模組註冊)    │  │ (文字路由)   │  │ (狀態機)  │  │
│  └───────────┘  └──────────────┘  └─────────────┘  └──────────┘  │
│                                                                     │
│  ┌─────────────┐  ┌────────────────┐  ┌──────────────────────┐   │
│  │   Sessions  │  │ Module         │  │  Working Context     │   │
│  │ (GS/CS/WS)  │  │ Coordinator    │  │  (跨模組資料共享)     │   │
│  └─────────────┘  └────────────────┘  └──────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
             │                                            ↑
┌────────────┴────────────────────────────────────────────┴───────────┐
│                    輸入層 (Input Layer)                              │
│  ┌──────────────────────────┐  ┌──────────────────────────┐        │
│  │      STT Module          │  │      (UI Module)         │        │
│  │  • Whisper-large-v3      │  │  • 文字輸入模式            │        │
│  │  • Pyannote Speaker ID   │  │                          │        │
│  │  • VAD (Energy-based)    │  │                          │        │
│  └──────────────────────────┘  └──────────────────────────┘        │
│                      │                                              │
│                      ↓                                              │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                    NLP Module                                 │  │
│  │  • Intent Segmentation (BIOS Tagger)                         │  │
│  │  • Identity Management                                       │  │
│  │  • State Decision Authority (IDLE → CHAT/WORK)              │  │
│  │  • Multi-Intent Context                                      │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                      │ [Publishes: INPUT_LAYER_COMPLETE]           │
└──────────────────────┴──────────────────────────────────────────────┘
                       ↓
┌─────────────────────────────────────────────────────────────────────┐
│                   處理層 (Processing Layer)                          │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    MEM Module                                │   │
│  │  • FAISS Vector Database (384-dim)                          │   │
│  │  • Sentence Transformers (all-MiniLM-L6-v2)                 │   │
│  │  • Identity-Isolated Memory                                 │   │
│  │  • Snapshot Manager (Conversation Snapshots)                │   │
│  │  • Semantic Retriever (Multi-Strategy RAG)                  │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    LLM Module                                │   │
│  │  • Google Gemini 2.5 Flash Lite (Vertex AI)                 │   │
│  │  • Structured Output (Pydantic Schemas)                     │   │
│  │  • MCP Client (Model Context Protocol)                      │   │
│  │  • Collaboration Channels:                                  │   │
│  │    - CHAT_MEM: LLM ↔ MEM (記憶增強對話)                      │   │
│  │    - WORK_SYS: LLM ↔ SYS (工作流決策與執行)                   │   │
│  │  • Context Caching (Gemini + Local)                         │   │
│  │  • Learning Engine (User Preference Tracking)               │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    SYS Module                                │   │
│  │  • Workflow Engine (Step-by-Step Execution)                 │   │
│  │  • MCP Server (Tool Protocol for LLM)                       │   │
│  │  • Background Task Executor (ThreadPoolExecutor)            │   │
│  │  • Function Registry (YAML-based)                           │   │
│  │  • Actions: Window Control, Text Processing, Integrations   │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                      │ [Publishes: PROCESSING_LAYER_COMPLETE]      │
└──────────────────────┴──────────────────────────────────────────────┘
                       ↓
┌─────────────────────────────────────────────────────────────────────┐
│                    輸出層 (Output Layer)                             │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                    TTS Module                                 │  │
│  │  • IndexTTS Lite Engine (Custom Transformer TTS)             │  │
│  │  • BigVGAN Vocoder (nvidia/bigvgan_v2_24khz)                 │  │
│  │  • Emotion Mapper (8D: happy, angry, sad, afraid, ...)      │  │
│  │  • TTS Chunker (Producer/Consumer Streaming)                 │  │
│  │  • Status Manager Integration (Mood/Pride/Helpfulness)       │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                      │ [Publishes: OUTPUT_LAYER_COMPLETE]          │
└──────────────────────┴──────────────────────────────────────────────┘
                       ↓
                   語音輸出 / UI 顯示
```

### 1.1.2 架構特點 (Architecture Highlights)

#### 1. 事件驅動 (Event-Driven)
- **Event Bus 核心**: 所有層級轉換透過 `core/event_bus.py` 解耦
- **非同步處理**: 模組間無直接依賴，僅透過事件訂閱/發布通訊
- **Flow-Based Deduplication**: 防止重複處理 (`session_id:cycle_index:layer`)

#### 2. 三層處理模型 (Three-Layer Processing)
| 層級 | 職責 | 主要模組 | 完成事件 |
|:---:|:---|:---|:---|
| **Input Layer** | 感知使用者輸入、決定系統狀態 | STT, NLP | `INPUT_LAYER_COMPLETE` |
| **Processing Layer** | 根據狀態執行對話或工作流 | MEM, LLM, SYS | `PROCESSING_LAYER_COMPLETE` |
| **Output Layer** | 語音合成與 UI 呈現 | TTS, UI | `OUTPUT_LAYER_COMPLETE` |

#### 3. 會話架構 (Session Architecture)
```
General Session (GS) ───┬── Chatting Session (CS)
系統級，跨越整個對話      │   CHAT 狀態專用
生命週期                 │   記憶隔離 (memory_token)
                        │   
                        └── Workflow Session (WS)
                            WORK 狀態專用
                            工作流狀態持久化
```

**會話生命週期**:
- **GS**: 第一次輸入開始 → 狀態佇列清空結束
- **CS**: CHAT 狀態進入創建 → CHAT 狀態退出結束
- **WS**: WORK 狀態進入創建 → 工作流完成或取消結束

#### 4. 協作通道 (Collaboration Channels)
| 通道 | 方向 | 用途 | 資料提供者 |
|:---:|:---:|:---|:---|
| **CHAT_MEM** | LLM ↔ MEM | 記憶檢索增強對話 | MEM Module |
| **WORK_SYS** | LLM ↔ SYS | 工作流狀態與函數註冊 | SYS Module |

**自動管理**: LLM Module 根據系統狀態自動啟用/停用對應通道

#### 5. 狀態管理 (State Management)
```
UEPState 狀態機:
IDLE ──→ CHAT (對話模式)
    └──→ WORK (工作流模式)
    └──→ ERROR (錯誤處理)
```

**狀態決策權**: NLP Module 分析意圖後決定狀態轉換

---

## 1.2 子系統功能與介面 (Subsystem Requirements and Interfaces)

### 1.2.1 核心控制層 (Core Control Layer)

| 子系統 ID | 子系統名稱 | 主要功能 | 檔案路徑 |
|:---:|:---|:---|:---|
| **CORE-001** | Controller | General Session 生命週期管理、系統健康監控 | `core/controller.py` |
| **CORE-002** | Framework | 模組自動發現與註冊、效能監控 | `core/framework.py` |
| **CORE-003** | Event Bus | 事件發布/訂閱、非同步事件處理 | `core/event_bus.py` |
| **CORE-004** | Module Coordinator | 層級轉換協調、Flow-Based 去重 | `core/module_coordinator.py` |
| **CORE-005** | Router | 純文字路由、表情符號過濾 | `core/router.py` |
| **CORE-006** | State Manager | 系統狀態追蹤、狀態佇列整合 | `core/states/state_manager.py` |
| **CORE-007** | Session Manager | 統一會話協調 (GS/CS/WS) | `core/sessions/session_manager.py` |
| **CORE-008** | Working Context | 跨模組資料共享、決策觸發 | `core/working_context.py` |
| **CORE-009** | Status Manager | 情緒值追蹤 (mood/pride/helpfulness/boredom) | `core/status_manager.py` |
| **CORE-010** | System Initializer | 7 階段系統初始化 | `core/system_initializer.py` |
| **CORE-011** | System Loop | 主處理迴圈、週期追蹤 | `core/system_loop.py` |

### 1.2.2 輸入層模組 (Input Layer Modules)

| 模組 ID | 模組名稱 | 主要功能 | 核心技術 |
|:---:|:---|:---|:---|
| **INPUT-001** | STT Module | 語音轉文字、說話者識別 | Whisper-large-v3, Pyannote |
| **INPUT-002** | NLP Module | 意圖分析、身份管理、狀態決策 | BIOS Tagger, IdentityManager |

### 1.2.3 處理層模組 (Processing Layer Modules)

| 模組 ID | 模組名稱 | 主要功能 | 核心技術 |
|:---:|:---|:---|:---|
| **PROC-001** | MEM Module | 向量記憶儲存與檢索 | FAISS, Sentence Transformers |
| **PROC-002** | LLM Module | 大型語言模型推理、結構化輸出 | Gemini 2.5 Flash, MCP Client |
| **PROC-003** | SYS Module | 工作流引擎、系統指令執行 | MCP Server, ThreadPoolExecutor |

### 1.2.4 輸出層模組 (Output Layer Modules)

| 模組 ID | 模組名稱 | 主要功能 | 核心技術 |
|:---:|:---|:---|:---|
| **OUTPUT-001** | TTS Module | 文字轉語音、情緒表達 | IndexTTS Lite, BigVGAN |
| **OUTPUT-002** | UI Module | 桌面寵物介面 | PyQt5 (可選) |

### 1.2.5 前端整合層 (Frontend Integration Layer)

| 模組 ID | 模組名稱 | 狀態 | 功能 |
|:---:|:---|:---:|:---|
| **FRONT-001** | Frontend Bridge | ✅ 已完成 | 後端控制器與前端 UI 的統一管理器 |
| **FRONT-002** | UI Module | ✅ 已完成 | 介面中樞、使用者工具、輸入處理 |
| **FRONT-003** | ANI Module | ✅ 已整合 | 動畫狀態同步與片段播放 |
| **FRONT-004** | MOV Module | ✅ 已整合 | 移動控制與行為狀態機 |
| **FRONT-005** | ON_CALL Manager | ✅ 已完成 | 快速呼叫模式管理 |
| **FRONT-006** | Frontend Event Bus | ✅ 已完成 | 前端模組同步事件系統 |

**Frontend Bridge 設計原則**:
- 統一管理 UI/MOV/ANI 三大前端模組生命週期
- 訂閱後端事件並轉換為前端事件（事件協調）
- ON_CALL 快速呼叫管理（VAD/文字雙模式）
- 雙模式支援：協調器模式（僅前端）與完整模式（含後端整合）

詳見 [第六章：展示層架構](./06_展示層架構.md) 完整說明。

### 1.2.6 主要介面定義 (Interface Definitions)

| 介面 ID | 介面名稱 | 類型 | 說明 |
|:---:|:---|:---:|:---|
| **INT-001** | Event Bus Interface | Event | 標準事件類型 (SystemEvent Enum) |
| **INT-002** | Module Handle Interface | Method | 所有模組實作 `handle(input) -> output` |
| **INT-003** | Collaboration Channel Interface | Data Provider | 模組註冊資料提供者 |
| **INT-004** | Working Context Interface | Shared Data | 跨模組資料存取 |
| **INT-005** | Session Interface | Lifecycle | 會話創建/查詢/結束 |
| **INT-006** | MCP Protocol Interface | RPC | LLM ↔ SYS 工具調用 |
| **INT-007** | Frontend Bridge Interface | ✅ Event/State | 後端 ↔ 前端狀態同步 |

---

## 1.3 技術解決方案限制 (Technical Solution Criteria)

### 1.3.1 優先次序表 (Priority Matrix)

依照系統需求，本設計文件擬定各種限制的優先順序如下：

| 考量因素 (Issue) | 使用者優先級 | 開發者優先級 | 系統優先級 |
|:---|:---:|:---:|:---:|
| **模組化 (Modularity)** | 2 | 1 | 1 |
| **可維護性 (Maintainability)** | 2 | 1 | 1 |
| **效能 (Performance)** | 1 | 2 | 1 |
| **可擴展性 (Scalability)** | 2 | 1 | 1 |
| **易用性 (Usability)** | 1 | 2 | 2 |
| **開發速度 (Development Speed)** | 2 | 2 | 3 |
| **成本 (Cost)** | 2 | 2 | 2 |

*優先級 (Scale: 1=最重要, 3=次要)*

### 1.3.2 篩選限制 (Screening Criteria)

依照上述的優先次序表，發展以下篩選限制：

| 限制 ID | 限制名稱 | 說明 | 權重 |
|:---:|:---|:---|:---:|
| **CRI-001** | 模組鬆耦合 (Loose Coupling) | 模組間透過事件通訊，無直接依賴 | ⭐⭐⭐ |
| **CRI-002** | 測試性 (Testability) | 每個模組可獨立測試 | ⭐⭐⭐ |
| **CRI-003** | 處理延遲 (Processing Latency) | 語音輸入到輸出 < 3 秒 (CHAT 模式) | ⭐⭐ |
| **CRI-004** | 記憶體使用 (Memory Usage) | 系統常駐記憶體 < 4GB | ⭐⭐ |
| **CRI-005** | 可擴展性 (Extensibility) | 新增模組無需修改核心程式碼 | ⭐⭐⭐ |
| **CRI-006** | 錯誤恢復 (Error Recovery) | 單一模組錯誤不影響系統運行 | ⭐⭐⭐ |
| **CRI-007** | 配置靈活性 (Configuration Flexibility) | 所有參數可透過 YAML 設定 | ⭐⭐ |
| **CRI-008** | Python 版本相容性 | 支援 Python 3.10+ | ⭐⭐⭐ |

---

## 1.4 架構方案比較 (Alternative Architecture Solutions)

### 1.4.1 方案概述

本專案在設計階段評估了以下三種架構方案：

| 方案 | 類型 | 說明 |
|:---:|:---|:---|
| **方案 A** | Monolithic Architecture | 單體式架構，所有功能整合在單一程式中 |
| **方案 B** | Direct Call Architecture | 模組間直接調用，無中介層 |
| **方案 C** | Event-Driven Architecture | 事件驅動架構，透過 Event Bus 解耦 ✅ (已選用) |

### 1.4.2 詳細比較

#### 方案 A: Monolithic Architecture (單體式架構)

**優點**:
- 開發初期速度快
- 無模組間通訊開銷
- 除錯容易 (單一執行路徑)

**缺點**:
- 難以擴展 (新增功能需修改核心程式碼)
- 測試困難 (無法隔離測試單一功能)
- 維護成本高 (修改影響範圍大)
- 無法支援動態模組載入

**評分** (依 1.3.2 標準):
| 限制 | 得分 | 說明 |
|:---|:---:|:---|
| 模組鬆耦合 | 2/10 | 所有功能緊密耦合 |
| 測試性 | 3/10 | 難以單元測試 |
| 處理延遲 | 8/10 | 無通訊開銷 |
| 記憶體使用 | 7/10 | 單一程序 |
| 可擴展性 | 2/10 | 擴展困難 |
| 錯誤恢復 | 2/10 | 單點失敗 |
| 配置靈活性 | 5/10 | 有限支援 |
| **總分** | **29/80** | |

---

#### 方案 B: Direct Call Architecture (直接調用架構)

**優點**:
- 模組化設計
- 執行流程清晰
- 開發相對簡單

**缺點**:
- 模組間存在直接依賴
- 難以替換或升級單一模組
- 測試需要 mock 依賴模組
- 流程變更需修改多處程式碼

**實際案例** (本專案 Phase 1):
```python
# deprecated/router_old.py
class OldRouter:
    def process_text(self, text):
        # 直接調用模組
        nlp_result = nlp_module.analyze(text)
        if nlp_result.intent == "CHAT":
            mem_result = mem_module.retrieve(text)
            llm_result = llm_module.generate(text, mem_result)
            tts_module.synthesize(llm_result.text)
```

**評分**:
| 限制 | 得分 | 說明 |
|:---|:---:|:---|
| 模組鬆耦合 | 5/10 | 模組化但有直接依賴 |
| 測試性 | 6/10 | 需要 mock 依賴 |
| 處理延遲 | 8/10 | 最小通訊開銷 |
| 記憶體使用 | 7/10 | 單一程序 |
| 可擴展性 | 5/10 | 可擴展但需修改調用方 |
| 錯誤恢復 | 4/10 | 依賴鏈中斷影響全局 |
| 配置靈活性 | 6/10 | 支援模組配置 |
| **總分** | **41/80** | |

---

#### 方案 C: Event-Driven Architecture (事件驅動架構) ✅

**優點**:
- 完全鬆耦合 (模組間無直接依賴)
- 易於測試 (模組獨立測試)
- 支援非同步處理
- 新增模組無需修改現有程式碼
- 錯誤隔離 (單一模組失敗不影響其他模組)
- 支援流程去重 (Flow-Based Deduplication)

**缺點**:
- 初始開發複雜度較高
- 除錯相對困難 (非線性執行流程)
- 有事件通訊開銷
- 需要良好的事件設計

**實際實作** (本專案 Phase 2):
```python
# core/event_bus.py
class EventBus:
    def publish(self, event_type, data):
        # 非同步通知所有訂閱者
        for callback in self.subscribers[event_type]:
            callback(data)

# modules/nlp_module/nlp_module.py
def handle(self, input):
    result = self._analyze(input)
    # 發布事件，無需知道誰訂閱
    event_bus.publish(SystemEvent.INPUT_LAYER_COMPLETE, result)
```

**評分**:
| 限制 | 得分 | 說明 |
|:---|:---:|:---|
| 模組鬆耦合 | 10/10 | ⭐ 完全解耦 |
| 測試性 | 9/10 | ⭐ 易於單元測試 |
| 處理延遲 | 6/10 | 事件通訊有開銷 |
| 記憶體使用 | 6/10 | Event Bus 佔用額外記憶體 |
| 可擴展性 | 10/10 | ⭐ 動態新增模組 |
| 錯誤恢復 | 9/10 | ⭐ 錯誤隔離 |
| 配置靈活性 | 8/10 | 模組與事件皆可配置 |
| **總分** | **58/80** | |

---

### 1.4.3 比較總表

| 評估項目 | 方案 A<br>(Monolithic) | 方案 B<br>(Direct Call) | 方案 C<br>(Event-Driven) ✅ |
|:---|:---:|:---:|:---:|
| **開發複雜度** | 低 | 中 | 高 |
| **維護成本** | 高 | 中 | 低 |
| **模組鬆耦合** | ❌ 差 | ⚠️ 中 | ✅ 優 |
| **測試性** | ❌ 差 | ⚠️ 中 | ✅ 優 |
| **可擴展性** | ❌ 差 | ⚠️ 中 | ✅ 優 |
| **錯誤恢復** | ❌ 差 | ⚠️ 中 | ✅ 優 |
| **處理延遲** | ✅ 優 | ✅ 優 | ⚠️ 中 |
| **記憶體使用** | ✅ 優 | ✅ 優 | ⚠️ 中 |
| **總分** | 29/80 | 41/80 | **58/80** |
| **適用場景** | 小型原型 | 中型專案 | 大型模組化系統 |

---

## 1.5 選擇方案說明 (Selected Solution Rationale)

### 1.5.1 選擇結論

經過詳細分析，本專案選擇 **方案 C: Event-Driven Architecture (事件驅動架構)**。

### 1.5.2 選擇理由

#### 1. 符合長期發展需求
U.E.P 專案預計持續迭代，需要頻繁新增模組 (如更多工作流類型、新的前端整合功能)。事件驅動架構允許無侵入式擴展，避免「改動一處，影響全局」的技術債。

#### 2. 支援複雜協作模式
系統需要支援多種模組組合：
- **CHAT 模式**: STT → NLP → MEM + LLM → TTS
- **WORK 模式**: STT → NLP → LLM + SYS → TTS
- **未來模式**: 可能有更多組合

事件驅動架構透過 `Module Coordinator` 動態選擇模組，無需修改核心程式碼。

#### 3. 錯誤隔離至關重要
AI 系統各模組 (STT、LLM、TTS) 皆可能失敗。事件驅動架構確保：
- STT 錯誤 → 僅影響本次輸入週期
- LLM 超時 → 不阻塞其他模組
- TTS 失敗 → 系統可降級為文字輸出

#### 4. 測試性提升開發效率
每個模組可獨立測試，無需啟動整個系統：
```python
# 單元測試範例
def test_nlp_module():
    nlp = NLPModule()
    result = nlp.handle({"text": "Hello"})
    assert result.primary_intent == IntentType.CHAT
```

#### 5. 前端整合已實現
Frontend Bridge 實現了多種後端事件監聽：
- `PROCESSING_LAYER_COMPLETE` → 更新動畫狀態
- `OUTPUT_LAYER_COMPLETE` → 同步口型動畫
- `SESSION_ENDED` → 重置 UI

事件驅動架構讓前端無需修改後端程式碼即可獲取所有必要事件。

### 1.5.3 克服缺點的策略

| 缺點 | 克服策略 | 實作證據 |
|:---|:---|:---|
| **除錯困難** | 事件歷史追蹤 | `event_bus.py`: 保留最近 100 個事件 |
| **處理延遲** | Flow-Based 去重 | `module_coordinator.py`: 防止重複處理 |
| **學習曲線陡** | 完整文件與範例 | 本 SDD 文件、`docs/事件驅動架構快速參考.md` |
| **記憶體開銷** | 事件佇列限制 | Event Bus 使用有界佇列 |

### 1.5.4 Phase 1 → Phase 2 重構證明

本專案實際從 Phase 1 (Direct Call) 重構為 Phase 2 (Event-Driven)，驗證了架構選擇的正確性：

**重構前問題**:
- 新增 SYS 模組需修改 Router、Controller 等 5+ 個檔案
- LLM 模組測試需要啟動 MEM 模組
- 狀態變更影響多處程式碼

**重構後改善**:
- 新增模組僅需實作 `handle()` 並訂閱事件
- 模組可完全獨立測試
- 狀態變更透過事件自動通知相關模組

---

## 1.6 介面需求與設計 (Interface Requirements and Design)

### 1.6.1 介面設計準則 (Interface Design Criteria)

依照系統架構，本系統對於介面設計的限制如下：

| 準則 ID | 準則名稱 | 說明 | 約束條件 |
|:---:|:---|:---|:---|
| **IFC-001** | 事件標準化 | 所有事件必須使用 `SystemEvent` Enum | 禁止使用字串事件名稱 |
| **IFC-002** | 資料結構化 | 模組輸入/輸出必須使用 Pydantic 模型 | 強制型別檢查 |
| **IFC-003** | 無狀態模組 | 模組不應依賴內部狀態 (除配置外) | 狀態存於 Working Context |
| **IFC-004** | 會話感知 | 所有事件需包含 `session_id` | 支援會話隔離 |
| **IFC-005** | 向後相容 | 新增欄位不應破壞現有模組 | 使用 `Optional` 欄位 |
| **IFC-006** | 錯誤透明化 | 模組錯誤必須透過標準格式回報 | 包含錯誤碼與訊息 |

### 1.6.2 核心介面設計 (Core Interface Designs)

#### 1.6.2.1 Event Bus Interface

**事件類型定義** (`core/schemas.py`):
```python
class SystemEvent(Enum):
    # 層級完成事件
    INPUT_LAYER_COMPLETE = "input_layer_complete"
    PROCESSING_LAYER_COMPLETE = "processing_layer_complete"
    OUTPUT_LAYER_COMPLETE = "output_layer_complete"
    
    # 週期事件
    CYCLE_COMPLETED = "cycle_completed"
    
    # 會話事件
    SESSION_STARTED = "session_started"
    SESSION_ENDED = "session_ended"
    
    # 工作流事件
    WORKFLOW_STEP_COMPLETED = "workflow_step_completed"
    WORKFLOW_FAILED = "workflow_failed"
    WORKFLOW_COMPLETED = "workflow_completed"
    
    # 狀態事件
    STATE_CHANGED = "state_changed"
```

**事件資料格式**:
```python
@dataclass
class EventData:
    session_id: str
    cycle_index: int
    timestamp: datetime
    source_module: str
    data: Dict[str, Any]
    metadata: Optional[Dict[str, Any]] = None
```

**訂閱/發布介面**:
```python
# 訂閱事件
event_bus.subscribe(SystemEvent.INPUT_LAYER_COMPLETE, callback)

# 發布事件
event_bus.publish(
    SystemEvent.INPUT_LAYER_COMPLETE,
    EventData(
        session_id="gs_12345",
        cycle_index=3,
        timestamp=datetime.now(),
        source_module="nlp_module",
        data={"primary_intent": "CHAT", ...}
    )
)
```

#### 1.6.2.2 Module Interface

**標準模組介面** (`core/bases/base_module.py`):
```python
class BaseModule(ABC):
    @abstractmethod
    def handle(self, input_data: BaseModel) -> BaseModel:
        """
        模組處理入口
        
        Args:
            input_data: 符合模組 Input Schema 的 Pydantic 模型
            
        Returns:
            符合模組 Output Schema 的 Pydantic 模型
        """
        pass
    
    @abstractmethod
    def get_name(self) -> str:
        """返回模組名稱"""
        pass
    
    @abstractmethod
    def get_capabilities(self) -> List[str]:
        """返回模組能力清單"""
        pass
```

**模組註冊介面**:
```python
def register() -> BaseModule:
    """
    模組註冊函數
    
    每個模組的 __init__.py 必須提供此函數
    供 Framework 自動發現並載入模組
    """
    return ModuleInstance()
```

#### 1.6.2.3 Collaboration Channel Interface

**資料提供者註冊** (`llm_module.py` 範例):
```python
# LLM 模組註冊資料提供者
working_context_manager.register_data_provider(
    channel_name="CHAT_MEM",
    provider_id="mem_module",
    data_type="memory_context",
    fetch_callback=lambda: mem_module.get_recent_memories()
)
```

**資料消費者存取**:
```python
# LLM 模組存取 MEM 提供的資料
memory_context = working_context_manager.get_channel_data(
    channel_name="CHAT_MEM",
    data_type="memory_context"
)
```

#### 1.6.2.4 Session Interface

**會話管理介面** (`core/sessions/session_manager.py`):
```python
class SessionManager:
    def create_general_session(self) -> str:
        """創建 General Session，返回 session_id"""
        pass
    
    def create_chatting_session(self, gs_id: str, identity_token: str) -> str:
        """創建 Chatting Session"""
        pass
    
    def create_workflow_session(self, gs_id: str, workflow_type: str) -> str:
        """創建 Workflow Session"""
        pass
    
    def get_current_session_id(self) -> Optional[str]:
        """獲取當前活躍會話 ID"""
        pass
    
    def end_session(self, session_id: str) -> None:
        """結束指定會話"""
        pass
```

#### 1.6.2.5 MCP Protocol Interface (LLM ↔ SYS)

**工具調用請求** (LLM → SYS):
```python
@dataclass
class MCPRequest:
    tool_name: str
    arguments: Dict[str, Any]
    session_id: str
    request_id: str
```

**工具調用回應** (SYS → LLM):
```python
@dataclass
class MCPResponse:
    request_id: str
    success: bool
    result: Optional[Dict[str, Any]]
    error: Optional[str]
```

**工具註冊** (`sys_module/functions.yaml`):
```yaml
start_workflow:
  description: "Start a new workflow"
  parameters:
    workflow_type:
      type: string
      required: true
      description: "Type of workflow to start"
    parameters:
      type: object
      required: false
      description: "Workflow-specific parameters"
```

#### 1.6.2.6 Frontend Bridge Interface (✅ 已實現 v0.8.0)

**後端 → 前端事件**:
```python
@dataclass
class FrontendEvent:
    event_type: FrontendEventType  # {STATE_CHANGE, TTS_START, TTS_END, ...}
    data: Dict[str, Any]
    timestamp: datetime
```

**前端 → 後端指令**:
```python
@dataclass
class FrontendCommand:
    command_type: FrontendCommandType  # {PAUSE, RESUME, CANCEL_TTS, ...}
    parameters: Dict[str, Any]
```

**狀態同步介面**:
```python
class FrontendAdapter:
    def sync_system_state(self, state: UEPState) -> None:
        """同步系統狀態到前端動畫"""
        pass
    
    def sync_tts_playback(self, audio_progress: float) -> None:
        """同步 TTS 播放進度到口型動畫"""
        pass
    
    def notify_processing_progress(self, layer: str, progress: float) -> None:
        """通知處理層進度 (如 LLM 生成進度)"""
        pass
```

---

### 1.6.3 介面版本管理 (Interface Versioning)

為確保系統可持續演進，所有介面遵循以下版本規則：

| 版本類型 | 變更範圍 | 向後相容性 | 範例 |
|:---|:---|:---:|:---|
| **Major** (v2.0) | 破壞性變更 | ❌ 否 | 改變事件資料結構 |
| **Minor** (v2.1) | 新增功能 | ✅ 是 | 新增 Optional 欄位 |
| **Patch** (v2.1.1) | 錯誤修正 | ✅ 是 | 修正型別標註 |

**當前版本**: v2.0 (Event-Driven Architecture)

---

### 1.6.4 介面測試策略 (Interface Testing Strategy)

每個介面需提供以下測試：

1. **單元測試**: 驗證介面定義正確性
2. **整合測試**: 驗證模組間介面契約
3. **向後相容測試**: 驗證新版本不破壞舊版本

**測試範例** (`tests/test_event_bus_interface.py`):
```python
def test_event_subscription():
    """測試事件訂閱介面"""
    received_events = []
    
    def callback(event_data):
        received_events.append(event_data)
    
    event_bus.subscribe(SystemEvent.INPUT_LAYER_COMPLETE, callback)
    event_bus.publish(
        SystemEvent.INPUT_LAYER_COMPLETE,
        EventData(session_id="test", cycle_index=1, ...)
    )
    
    assert len(received_events) == 1
    assert received_events[0].session_id == "test"
```

---

## 總結 (Summary)

本章節說明了 U.E.P 系統的整體架構設計，包括：

✅ **系統架構概覽**: 三層事件驅動架構，透過 Event Bus 實現鬆耦合  
✅ **子系統功能與介面**: 11 個核心子系統 + 7 個模組 + 前端整合層  
✅ **技術解決方案限制**: 8 項關鍵限制與優先級評估  
✅ **架構方案比較**: 評估 3 種方案，選擇事件驅動架構 (得分 58/80)  
✅ **選擇方案說明**: 詳述選擇理由與克服缺點的策略  
✅ **介面需求與設計**: 定義 6 大核心介面與版本管理策略  

下一章將深入探討 [核心子系統架構](./02_核心子系統.md)，包括 Controller、Framework、Event Bus、Module Coordinator 等的詳細設計。

---

[→ 下一章：核心子系統](./02_核心子系統.md)  
[← 返回主文件](../System%20Design%20Documentation.md)
