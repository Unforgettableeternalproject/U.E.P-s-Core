# 核心框架整合指南

## 概述

新的核心框架已經成功整合了 Working Context、State Management 和智能路由系統，實現了從線性模組通信轉為網狀結構的重構目標。

## 主要改進

### 核心架構實現 ✅

#### 核心框架（`core/framework.py`）
- **統一的模組註冊系統**：支援動態模組註冊和能力管理
- **智能路由引擎**：根據意圖和上下文自動決定處理流程
- **狀態管理整合**：與 UEP 狀態系統完全整合
- **事件驅動架構**：支援模組間的非同步通信

#### 統一控制器（`core/unified_controller.py`）
- **模組生命週期管理**：自動初始化、註冊和清理模組
- **配置驅動**：基於 `config.yaml` 的模組啟用控制
- **決策處理器註冊**：自動註冊 Working Context 決策處理器
- **錯誤恢復機制**：模組載入失敗時的優雅降級

#### 智能路由策略（`core/strategies.py`）
- **Smart Strategy**：基於模組能力的智能路由
- **Priority Strategy**：基於優先級的順序路由
- **Conditional Strategy**：基於條件的動態路由
- **Context Decision Engine**：整合上下文信息的決策引擎

### Working Context 整合 ✅

#### 語者識別上下文處理
```python
# 在 STT 模組中使用 Working Context
from core.working_context import working_context_manager, ContextType

# 累積語者識別數據
working_context_manager.add_data(
    context_id=f"speaker_{speaker_id}",
    context_type=ContextType.SPEAKER_ACCUMULATION,
    data=speaker_data,
    threshold=15  # 需要15個樣本才觸發決策
)
```

#### 自動決策觸發
- 當累積足夠樣本時，自動觸發語者識別決策
- 支援多種上下文類型的並行處理
- 會話結束時自動清理未完成的上下文

## 架構重構進展

### 已完成的重構 ✅

#### 調試功能分離
- **devtools/debug_functions.py** - 所有調試和測試功能已遷移
- **core/controller.py** - 標記為逐步棄用，保留向後兼容
- **ModuleDebugger 類** - 提供結構化的調試工具

#### 統一 Schema 設計
- **core/schemas.py** - 定義統一的模組數據格式
- **UnifiedModuleData** - 基礎數據結構
- **模組專用 Schema** - STT, NLP, MEM, LLM, TTS, SYS
- **LegacyDataAdapter** - 向後兼容適配器

#### 核心架構優化
```python
# 新的架構分工

core/controller.py:    # 系統控制器
├── 系統生命週期管理
├── 模組註冊和協調  
├── 事件處理和狀態管理
└── 決策引擎協調

devtools/debug_api.py:  # 調試工具集
├── 模組功能測試
├── 性能監控和統計
├── 開發調試工具
└── 系統診斷功能

core/framework.py:            # 執行引擎
├── 執行引擎和管道處理
├── 路由決策和模組調度
└── 數據轉換協調

core/schemas.py:              # 數據標準
├── 統一數據 Schema
├── 模組專用格式
├── 向後兼容適配
└── 數據驗證
```

## 使用方式更新

### 調試工具使用

```python
# 新的調試方式
from devtools.debug_functions import module_debugger

# 模組測試
module_debugger.stt_test_single()
module_debugger.nlp_test("測試文本")
module_debugger.mem_fetch_test("記憶查詢")
module_debugger.llm_test_chat("聊天測試")
module_debugger.tts_test("語音合成")

# 系統診斷
module_debugger.get_working_context_status()
module_debugger.stt_get_stats()

# 向後兼容 (仍可用但不推薦)
from devtools.debug_functions import stt_test_single
```

### 統一 Schema 使用

```python
from core.schemas import create_nlp_data, create_mem_data, LegacyDataAdapter

# 創建標準格式數據
nlp_data = create_nlp_data(
    text="你好",
    intent="chat",
    confidence=0.95
)

# 舊格式適配
legacy_data = {"text": "測試", "intent": "chat"}
unified_data = LegacyDataAdapter.adapt_to_unified(legacy_data, "nlp")
```

## 使用方式

### 1. 基本初始化

```python
from core.unified_controller import UnifiedController

# 創建統一控制器
controller = UnifiedController()

# 初始化系統（自動載入配置中啟用的模組）
if controller.initialize():
    print("✅ 系統初始化成功")
else:
    print("❌ 系統初始化失敗")
```

### 2. 執行處理管線

```python
from core.framework import core_framework

# 同步執行
result = core_framework.execute_pipeline(
    intent="voice_recognition",
    data={"audio_data": audio_bytes},
    mode="sync"
)

# 非同步執行
async def process_audio():
    result = await core_framework.execute_pipeline(
        intent="voice_recognition", 
        data={"audio_data": audio_bytes},
        mode="async"
    )
```

### 3. 狀態管理

```python
from core.state_manager import UEPState

# 變更系統狀態
controller.change_state(UEPState.CHAT)

# 獲取當前狀態
current_state = core_framework.get_current_state()
```

### 4. Working Context 操作

```python
from core.working_context import working_context_manager

# 獲取所有上下文狀態
contexts = working_context_manager.get_all_contexts_info()

# 清理會話結束時的上下文
controller.cleanup_session_contexts(min_samples=15)
```

## 與現有控制器的整合

### 1. 保持向後相容性

現有的 `controller.py` 中的函數（如 `stt_test_single`、`nlp_test` 等）可以繼續使用，但建議逐步遷移到新的核心框架：

```python
# 舊方式（仍然可用）
def stt_test_single(mode="manual", enable_speaker_id=True, language="en-US"):
    stt = modules["stt"]
    result = stt.handle({"mode": mode, "language": language, ...})
    return result

# 新方式（推薦）
def stt_test_with_framework(mode="manual", enable_speaker_id=True, language="en-US"):
    result = core_framework.execute_pipeline(
        intent="voice_recognition",
        data={
            "stt_params": {
                "mode": mode,
                "language": language,
                "enable_speaker_id": enable_speaker_id
            }
        },
        mode="sync"
    )
    return result
```

### 2. 逐步遷移計劃

#### 階段 1：保持雙軌運行 ✅
- 新核心框架與舊控制器並存
- 關鍵功能通過新框架測試驗證
- 保持現有測試和演示功能正常

#### 階段 2：核心功能遷移（下一步）
- 將 STT、NLP、MEM 等核心模組的調用遷移到新框架
- 使用新的智能路由替代現有的手動模組調用
- 整合 Working Context 到所有模組操作

#### 階段 3：完全替換（最終目標）
- 移除舊的控制器邏輯
- 所有模組通信通過核心框架進行
- 實現完全的網狀模組架構

## 配置要求

確保 `configs/config.yaml` 中正確配置模組啟用狀態：

```yaml
modules_enabled:
  stt_module: true    # 語音識別
  nlp_module: true    # 自然語言處理
  mem_module: true    # 記憶管理
  llm_module: true    # 大語言模型
  tts_module: true    # 文字轉語音
  sys_module: true    # 系統控制
```

## 測試和驗證

### 1. 運行核心框架測試
```bash
python test_core_framework.py
```

### 2. 運行完整演示
```bash
python demo_framework_usage.py
```

### 3. 檢查模組載入狀態
```python
from core.framework import core_framework

# 檢查已註冊的模組
registered_modules = core_framework.get_registered_modules()
print("已註冊模組:", list(registered_modules.keys()))

# 檢查模組能力
for capability in ["speech_recognition", "language_model", "memory_storage"]:
    module = core_framework.find_module_by_capability(capability)
    print(f"能力 '{capability}': {module or '無模組'}")
```

## 效能優化

### 1. 模組懶載入
- 模組只在需要時載入和初始化
- 減少系統啟動時間和記憶體使用

### 2. 智能路由快取
- 常用路由決策結果被快取
- 減少重複計算開銷

### 3. 上下文自動清理
- 定期清理過期或不完整的上下文
- 防止記憶體洩漏

## 故障排除

### 1. 模組載入失敗
- 檢查 `config.yaml` 中的模組名稱是否正確
- 確認模組依賴是否已安裝
- 查看日誌文件了解具體錯誤信息

### 2. Working Context 問題
- 檢查決策處理器是否正確註冊
- 確認上下文類型和閾值設置
- 使用 `get_working_context_status()` 檢查狀態

### 3. 路由決策失敗
- 確認目標模組已正確註冊
- 檢查模組能力聲明是否正確
- 查看路由策略的匹配邏輯

## 下一步計劃

1. **NLP 模組整合**：將聊天快照處理整合到 Working Context
2. **LLM-SYS 互動**：實現 LLM 和 SYS 模組間的智能路由
3. **前端整合準備**：為 UI 模組預留接口和狀態管理
4. **效能監控**：添加詳細的效能指標和監控功能

---