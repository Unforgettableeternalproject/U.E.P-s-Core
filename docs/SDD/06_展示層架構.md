# 第六章：展示層架構 (Presentation Layer Architecture)

[← 上一章：模組設計 - 輸出層](./05_模組設計_輸出層.md) | [下一章：系統流程 →](./07_系統流程.md) | [返回主文件](../SDD.md)

## 6.1 展示層概述

### 6.1.1 設計目標

展示層是 U.E.P 系統中負責**使用者互動與視覺呈現**的完整子系統，在 Phase 3 實現了前後端的深度整合。設計目標包括：

1. **統一前端管理**：透過 Frontend Bridge 實現三大前端模組（UI/MOV/ANI）的生命週期統一控制
2. **事件驅動協作**：前端獨立事件系統與後端 Event Bus 解耦，提升響應性能
3. **使用者工具完整性**：提供系統設定、狀態監控、快速操作的完整介面
4. **無縫狀態同步**：前後端狀態即時同步，動畫與系統行為一致

### 6.1.2 三大前端模組職責

| 模組 | 核心職責 | 關鍵特性 |
|------|---------|---------|
| **UI 模組** | 介面中樞、使用者工具、輸入處理 | PyQt5 無邊框視窗、透明背景、60 FPS 刷新 |
| **MOV 模組** | 桌寵移動控制、物理模擬、行為狀態機 | 重力/摩擦模擬、狀態感知移動、邊界檢測 |
| **ANI 模組** | 動畫片段管理、幀播放、狀態追蹤 | 配置驅動、Alias 映射、Transform 快取 |

### 6.1.3 與後端系統整合

展示層透過以下機制與核心系統整合：

- **Frontend Bridge**：統一前端管理器，處理前後端事件轉換與生命週期控制
- **Frontend Event Bus**：高性能同步事件系統，專門處理前端模組間快速通訊
- **Working Context**：共享工作上下文，前端可讀取當前會話、狀態、系統數值
- **StatusManager**：情緒與狀態數值驅動動畫與行為選擇

---

## 6.2 Frontend Bridge 核心設計

### 6.2.1 統一前端管理器

**Frontend Bridge** (`core/frontend_bridge.py`) 是展示層的中樞控制器，負責：

#### 職責
1. **生命週期管理**：初始化、啟動、關閉三大前端模組
2. **事件協調**：訂閱後端事件並轉換為前端事件
3. **ON_CALL 管理**：處理快速呼叫模式的啟動與結束
4. **模式切換**：支援「協調器模式」（僅管理）與「完整模式」（包含後端整合）

#### 雙模式設計

**協調器模式**（Coordinator Mode）
- 僅初始化前端三模組，不訂閱後端事件
- 用於前端獨立測試或輕量級展示
- 模組間通訊透過 Frontend Event Bus

**完整模式**（Full Mode）
- 從 Registry 載入前端模組實例
- 訂閱後端 Event Bus 的系統事件
- 建立前後端雙向通訊管道
- 整合 Working Context 與 StatusManager

### 6.2.2 關鍵方法與流程

#### 初始化流程
1. **模組載入**：從 Registry 取得 UI/MOV/ANI 模組實例
2. **事件訂閱**：訂閱 `STATE_CHANGED`、`SESSION_STARTED`、`SESSION_ENDED` 等後端事件
3. **前端連接**：建立 UI-MOV、UI-ANI、MOV-ANI 模組間連接
4. **ON_CALL 設置**：初始化 ON_CALL 管理器，綁定快速呼叫按鈕

#### 事件處理流程
- **狀態變更**：`_handle_state_changed()` → 通知 ANI 切換動畫 → 通知 MOV 調整行為
- **會話開始**：`_handle_session_started()` → 更新 UI 顯示 → 記錄當前會話 ID
- **會話結束**：`_handle_session_ended()` → 清理會話標記 → 恢復 IDLE 狀態

#### ON_CALL 管理
- **啟動 ON_CALL**：設置 `activation_flag`，VAD 模式跳過 CALL 意圖檢測；文字模式彈出輸入框
- **結束 ON_CALL**：清除標記，關閉輸入框，ANI 恢復正常動畫
- **文本注入**：將使用者輸入直接送入後端 STT 模組處理

### 6.2.3 與其他子系統協作

| 協作對象 | 互動方式 | 用途 |
|---------|---------|------|
| **Event Bus** | 訂閱後端事件 | 接收系統狀態變更、會話事件、工作流更新 |
| **Working Context** | 讀取共享上下文 | 取得當前會話、狀態、協作通道資訊 |
| **StatusManager** | 讀取情緒數值 | 驅動動畫與行為選擇（mood/boredom/pride） |
| **Module Coordinator** | 透過 Registry 取得模組 | 載入前端模組實例、檢查模組健康度 |
| **NLP 模組** | 設置 activation_flag | ON_CALL 模式跳過 CALL 意圖檢測 |

---

## 6.3 前端事件系統與 Event Bus 整合

### 6.3.1 Frontend Event Bus 設計

**Frontend Event Bus** (`modules/ui_module/frontend_event_bus.py`) 是專為前端模組設計的**同步高性能事件系統**。

#### 設計差異

| 特性 | Frontend Event Bus | 後端 Event Bus |
|------|-------------------|---------------|
| **執行模式** | 同步立即執行 | 異步任務佇列 |
| **適用場景** | UI 更新、動畫切換 | 跨模組協作、工作流執行 |
| **性能要求** | 60 FPS 即時響應 | 可容忍毫秒級延遲 |
| **錯誤處理** | 快速失敗 | 完整重試機制 |

#### 核心特性
- **同步執行**：事件發布後立即執行所有訂閱者，保證 UI 更新即時性
- **類型安全**：使用 `FrontendEventType` 枚舉，避免字串錯誤
- **輕量級**：無歷史記錄、無重試機制，專注於高頻更新

### 6.3.2 事件類型定義

**前端事件類型** (`modules/ui_module/event_types.py`)：

| 事件類型 | 觸發時機 | 訂閱者 |
|---------|---------|--------|
| `ANIMATION_CHANGED` | ANI 切換動畫片段 | UI（更新顯示幀）、MOV（調整移動速度） |
| `MOVEMENT_UPDATED` | MOV 更新座標 | UI（刷新視窗位置） |
| `BEHAVIOR_CHANGED` | MOV 切換行為狀態 | ANI（觸發對應動畫） |
| `UI_INTERACTION` | 使用者點擊/拖拽 | MOV（切換至 DRAGGING 模式） |
| `SETTINGS_UPDATED` | 設定面板修改配置 | UI/MOV/ANI（熱重載設定） |

### 6.3.3 前後端事件轉換

Frontend Bridge 負責將**後端系統事件**轉換為**前端事件**：

**轉換映射表**

| 後端事件 | 轉換邏輯 | 前端事件 |
|---------|---------|---------|
| `STATE_CHANGED` | 取得新狀態 → 查詢動畫映射 | `ANIMATION_CHANGED` |
| `TTS_SPEAKING_STARTED` | 標記語音播放中 | `ANIMATION_CHANGED`（mouth_open） |
| `TTS_SPEAKING_ENDED` | 清除播放標記 | `ANIMATION_CHANGED`（恢復 idle） |
| `SESSION_STARTED` (WORK) | 識別工作流類型 | `BEHAVIOR_CHANGED`（切換至 FOCUSED） |

**範例流程：狀態變更觸發動畫**
1. 後端發布 `STATE_CHANGED(new_state=CHAT)`
2. Frontend Bridge 接收事件
3. 查詢 ANI 模組的狀態-動畫映射表
4. 發布前端事件 `ANIMATION_CHANGED(animation="chat_idle")`
5. UI 模組接收 → 通知 ANI 載入新動畫片段
6. MOV 模組接收 → 切換至 FOCUSED 行為（減少移動）

---

## 6.4 使用者工具系統

### 6.4.1 Access Widget 快速存取小工具

**Access Widget** (`modules/ui_module/user/access_widget.py`) 是**懸浮球體介面**，提供三個核心快速動作按鈕。

#### 三大快速動作

**1. 顯示/隱藏 UEP**
- **功能**：一鍵切換桌面寵物主視窗可見性
- **動畫整合**：隱藏時播放離場動畫（fade_out），顯示時播放進場動畫（fade_in）
- **狀態同步**：透過 Frontend Bridge 通知 UI 模組更新視窗顯示狀態

**2. ON_CALL 呼叫 UEP**
- **VAD 模式**：
  - 設置 NLP 模組的 `activation_flag = True`
  - 跳過 CALL 意圖檢測，直接處理語音輸入
  - ANI 播放 notice 動畫，提示使用者可以說話
  - 支持二次點擊取消（恢復正常模式）
  
- **文字模式**：
  - 彈出 ON_CALL 輸入框 (`modules/ui_module/on_call/input_dialog.py`)
  - 使用者輸入文字後，透過 Frontend Bridge 注入到後端
  - 暫停 MOV/ANI 模擬，等待輸入完成

**3. 睡眠狀態切換**
- **進入睡眠**：
  - 發布 `SLEEP_REQUEST` 事件到後端
  - State Manager 檢查條件（無活動會話、無背景任務）
  - 卸載後端模組（STT/NLP/MEM/LLM/SYS/TTS）
  - 前端模組**不卸載**，繼續響應喚醒請求
  - ANI 播放睡眠動畫（g_to_s）
  
- **喚醒系統**：
  - 檢測使用者輸入（語音/文字/點擊）
  - 發布 `WAKE_REQUEST` 事件
  - 異步並行重載所有後端模組
  - 等待 `WAKE_READY` 事件（模組重載完成）
  - ANI 播放喚醒動畫（s_to_g）
  - 恢復正常系統運作

#### 自動隱藏機制

**Auto Hide Manager** (`modules/ui_module/user/auto_hide_manager.py`)：
- **觸發條件**：滑鼠離開小工具區域超過 2 秒
- **行為**：淡出至 30% 不透明度，減少視覺干擾
- **恢復**：滑鼠懸停立即恢復 100% 不透明度

### 6.4.2 Settings Panel 使用者設定面板

**Settings Panel** (`modules/ui_module/user/settings_panel.py`) 提供**9 大分類**的完整設定介面。

#### 設定分類與關鍵項目

| 分類 | 關鍵設定項目 | 影響範圍 |
|------|------------|---------|
| **基礎設定** | 除錯等級、日誌等級、語言偏好 | 全系統 |
| **身分設定** | 身分名稱、認證憑證 | MEM/LLM/NLP 模組 |
| **語音輸入** | VAD 靈敏度、說話人識別 | STT 模組 |
| **語音輸出** | 音量、情感強度、播放速度 | TTS 模組 |
| **記憶系統** | 記憶啟用、檢索數量、快取大小 | MEM 模組 |
| **對話模型** | 模型選擇、溫度參數、上下文快取 | LLM 模組 |
| **行為設定** | MISCHIEF 頻率、SLEEP 自動觸發 | State Manager |
| **介面設定** | 主題、透明度、動畫 FPS | UI/MOV/ANI 模組 |
| **效能設定** | 並行任務數、記憶體限制 | Framework |

#### 配置熱重載機制

**UserSettingsManager** (`configs/user_settings_manager.py`) 實現設定變更即時生效：

1. **變更檢測**：Settings Panel 修改設定後呼叫 `update_setting(key, value)`
2. **驗證與持久化**：驗證新值合法性，寫入 `configs/user_settings.yaml`
3. **事件發布**：發布 `SETTINGS_UPDATED` 事件到 Frontend Event Bus
4. **模組熱重載**：
   - 各模組訂閱 `SETTINGS_UPDATED` 事件
   - 重新讀取配置文件
   - 更新內部狀態（如 VAD 靈敏度、TTS 音量）
   - 無需重啟系統

#### 身分設置整合

**Identity Token 系統**：
- **預設身分**：未設置時使用 `default_user`，無身分隔離
- **自訂身分**：設置後，MEM 模組為該身分建立獨立 FAISS 索引
- **切換身分**：Settings Panel 切換時，觸發 MEM 模組載入對應記憶庫
- **安全性**：身分憑證加密存儲，僅用於多使用者記憶隔離

### 6.4.3 Status Panel 系統狀態面板

**Status Panel** (`modules/ui_module/user/status_panel.py`) 顯示**即時系統健康度與效能指標**。

#### 顯示區域

**1. 系統概覽**
- **運行時間**：系統啟動後的累計運行時間
- **當前狀態**：IDLE/CHAT/WORK/MISCHIEF/SLEEP
- **活動會話**：當前 General Session 數量

**2. 模組健康度**
- **綠色**：模組正常運作
- **黃色**：模組警告狀態（如記憶體使用 > 80%）
- **紅色**：模組錯誤或離線
- **顯示模組**：STT, NLP, MEM, LLM, SYS, TTS, UI, MOV, ANI

**3. 效能指標**
- **CPU 使用率**：當前系統 CPU 佔用（%）
- **記憶體使用**：已用記憶體 / 總記憶體（MB）
- **事件處理延遲**：Event Bus 平均事件處理時間（ms）
- **TPS (Tokens Per Second)**：LLM 生成速度

**4. 系統數值提示**（隱式顯示）
- **範例文字**：「UEP 看起來有點無聊...」（Boredom 高）
- **範例文字**：「系統狀態良好，心情愉快！」（Mood 高）
- **目的**：避免直接顯示數值，用自然語言暗示

#### 更新機制
- **刷新頻率**：每 1 秒更新一次
- **資料來源**：Framework 的 `get_all_metrics()` 方法
- **健康檢查**：Module Coordinator 的 `check_module_health()`

### 6.4.4 Monitor Panel 系統監控面板

**Monitor Panel** (`modules/ui_module/user/monitor_panel.py`) 提供**背景任務與服務監控**。

#### 監控內容

**1. 背景任務追蹤**
- **資料來源**：SYS 模組的背景任務列表
- **顯示資訊**：任務名稱、進度、預計完成時間
- **互動**：支援取消任務、查看詳細日誌

**2. 待辦事項與行事曆**
- **資料來源**：SYS 模組的 TODO/CALENDAR 工作流
- **功能**：查看近期待辦、新增快速事項、標記完成

**3. 音樂播放控制**
- **資料來源**：SYS 模組的 PLAY_MEDIA 工作流狀態
- **控制項**：播放/暫停、上一首/下一首、音量調整、進度條
- **顯示**：當前播放曲目、專輯封面（如有）、播放進度

**4. 日誌查看器**（可選）
- **啟用條件**：`user_settings.yaml` 中 `debug.show_logs = true`
- **顯示內容**：即時串流 `logs/runtime/` 中的最新日誌
- **過濾**：支援按模組、等級（INFO/WARNING/ERROR）過濾

---

## 6.5 ON_CALL 快速呼叫機制

### 6.5.1 設計目標

**ON_CALL** 是快速啟動系統互動的機制，無需等待 VAD 檢測 CALL 意圖，直接進入對話模式。

**使用場景**：
- 使用者想快速提問，不想說「嘿 UEP」等喚醒詞
- 文字輸入模式下，避免在終端輸入
- 測試與除錯時快速注入輸入

### 6.5.2 ON_CALL Manager 實作

**ON_CALL Manager** (`modules/ui_module/on_call/on_call_manager.py`) 管理快速呼叫的完整生命週期。

#### 啟動流程

**VAD 模式**：
1. 使用者點擊 Access Widget 的 ON_CALL 按鈕
2. ON_CALL Manager 設置 NLP 模組的 `activation_flag = True`
3. Frontend Bridge 通知 ANI 播放 notice 動畫
4. MOV 暫停正常行為模擬（固定位置）
5. 系統進入監聽狀態，等待語音輸入
6. VAD 檢測到語音 → STT 轉錄 → NLP 跳過 CALL 檢測 → 直接處理
7. 處理完成後自動清除 `activation_flag`

**文字模式**：
1. 使用者點擊 ON_CALL 按鈕
2. 彈出 ON_CALL Input Dialog (`modules/ui_module/on_call/input_dialog.py`)
3. 使用者輸入文字並按下送出
4. Frontend Bridge 呼叫 `inject_text_input(text)`
5. 文字直接傳入 NLP 模組，跳過 STT
6. 關閉輸入框，恢復正常模擬

#### 取消機制

**二次點擊取消**：
- 使用者在 ON_CALL 啟動後再次點擊按鈕
- ON_CALL Manager 檢測到重複點擊
- 清除 `activation_flag`
- 關閉輸入框（如有）
- ANI 恢復正常動畫

**自動超時**：
- VAD 模式下，30 秒無語音輸入自動取消
- 文字模式下，2 分鐘無操作自動關閉輸入框

### 6.5.3 與 NLP 模組協作

**activation_flag 機制**：

NLP 模組在處理輸入時檢查此標記：
- **標記存在**：跳過 CALL 意圖檢測，直接標記為有效輸入
- **標記不存在**：正常檢查 CALL 意圖，若無則忽略輸入

**標記生命週期**：
- **設置**：ON_CALL Manager 啟動時
- **清除**：單次輸入處理完成後（NLP 自動清除）或使用者取消

---

## 6.6 前後端協作完整流程

### 6.6.1 狀態同步流程

**範例：IDLE → CHAT 狀態轉換**

1. **觸發**：使用者語音輸入「今天天氣如何？」
2. **後端處理**：
   - STT 轉錄文字
   - NLP 檢測 CALL 意圖 → 標記為有效輸入
   - State Manager 判斷需創建 CHAT 狀態
   - 發布 `STATE_CHANGED(old=IDLE, new=CHAT)` 事件
3. **Frontend Bridge 處理**：
   - 接收 `STATE_CHANGED` 事件
   - 更新 `current_state = CHAT`
   - 查詢 ANI 模組的狀態-動畫映射
4. **前端響應**：
   - **ANI 模組**：切換至 `chat_idle` 動畫（更專注的姿態）
   - **MOV 模組**：切換至 FOCUSED 行為（減少移動範圍）
   - **UI 模組**：更新主視窗標題（顯示「對話中」）
5. **LLM 生成回應**：「今天台北晴朗，氣溫 25°C。」
6. **TTS 播放**：
   - 發布 `TTS_SPEAKING_STARTED` 事件
   - ANI 播放口型動畫（mouth_open）
   - TTS 播放完成後發布 `TTS_SPEAKING_ENDED`
   - ANI 恢復 `chat_idle`

### 6.6.2 動畫事件流

**範例：工作流執行觸發特殊動畫**

1. **工作流開始**：使用者說「幫我找桌面的文件」
2. **後端處理**：
   - NLP 識別為 SEARCH_FILE 意圖
   - 創建 Workflow Session
   - 發布 `SESSION_STARTED(type=WORKFLOW, workflow=SEARCH_FILE)`
3. **Frontend Bridge 處理**：
   - 接收事件 → 識別工作流類型
   - 發布前端事件 `BEHAVIOR_CHANGED(behavior=WORKING)`
4. **前端響應**：
   - **ANI**：播放 `work_searching` 動畫（左右掃視）
   - **MOV**：切換至 EXCITED 行為（小幅度跳動）
5. **工作流進度更新**：
   - SYS 模組搜尋檔案中
   - 發布 `WORKFLOW_STEP_COMPLETED` 事件
   - UI 在 Monitor Panel 更新進度條
6. **工作流完成**：
   - 發布 `SESSION_ENDED(result=success)`
   - ANI 播放 `work_complete` 動畫（點頭）
   - 恢復 IDLE 狀態

### 6.6.3 使用者輸入處理流程

**範例：拖拽桌寵**

1. **使用者操作**：滑鼠點擊並拖拽桌寵
2. **UI 模組檢測**：
   - Drag Handler 檢測到 `mousePressEvent`
   - 發布前端事件 `UI_INTERACTION(type=DRAG_START)`
3. **MOV 模組響應**：
   - 接收事件 → 切換至 DRAGGING 模式
   - 停止物理模擬（關閉重力與摩擦）
   - 位置由滑鼠座標直接控制
4. **ANI 模組響應**：
   - 接收事件 → 切換至 `dragged` 動畫（被抓取的表情）
5. **拖拽中**：
   - UI 模組持續發布 `MOVEMENT_UPDATED(x, y)` 事件
   - MOV 更新內部座標
   - UI 即時刷新視窗位置
6. **放開滑鼠**：
   - UI 發布 `UI_INTERACTION(type=DRAG_END)`
   - MOV 切換至 THROWN 模式（投擲狀態）
   - 根據最後速度施加慣性
   - ANI 播放 `fly_spin` 動畫
   - 落地後恢復正常物理模擬

**範例：ON_CALL 文字輸入**

1. **使用者點擊**：Access Widget 的 ON_CALL 按鈕
2. **ON_CALL Manager**：
   - 彈出 Input Dialog
   - ANI 播放 notice 動畫
   - MOV 暫停行為模擬
3. **使用者輸入**：「提醒我明天開會」
4. **Frontend Bridge**：
   - 接收輸入文字
   - 呼叫 `inject_text_input("提醒我明天開會")`
   - 將文字包裝為 STT 輸出格式
5. **後端處理**：
   - NLP 接收文字 → 識別為 CREATE_TODO 意圖
   - 創建 Workflow Session
   - SYS 執行 CREATE_TODO 工作流
   - LLM 確認：「已新增待辦事項：明天開會」
6. **前端恢復**：
   - ON_CALL Manager 關閉輸入框
   - ANI 恢復正常動畫
   - MOV 恢復行為模擬

---

## 6.7 前端模組協作案例

### 6.7.1 案例一：狀態變更觸發動畫

**場景**：系統從 IDLE 進入 MISCHIEF 狀態

**完整流程**：

1. **觸發條件**：State Manager 檢測到 `Boredom >= 0.6` 且 `Mood <= -0.3`
2. **狀態創建**：
   - State Manager 在狀態佇列中加入 MISCHIEF 狀態
   - 發布 `STATE_CHANGED(old=IDLE, new=MISCHIEF)` 事件
3. **Frontend Bridge 響應**：
   - 訂閱者接收事件
   - 呼叫 `_handle_state_changed(old=IDLE, new=MISCHIEF)`
   - 查詢 ANI 的狀態映射表 → `mischief_idle`
4. **ANI 模組**：
   - 接收 `ANIMATION_CHANGED(animation=mischief_idle)`
   - 載入調皮表情動畫（壞笑、眨眼等）
   - 檢查 Cooldown（避免重複切換）
   - 開始播放動畫幀
5. **MOV 模組**：
   - 接收狀態變更通知
   - 切換至 EXCITED 行為（更活躍的移動）
   - 提升移動速度與隨機性
6. **MISCHIEF 行為執行**：
   - LLM 規劃搗蛋行為序列
   - ANI 根據行為類型播放對應動畫（如移動視窗時播放 `mischief_move` 動畫）
7. **MISCHIEF 結束**：
   - 行為序列執行完畢
   - State Manager 移除 MISCHIEF 狀態
   - 發布 `STATE_CHANGED(old=MISCHIEF, new=IDLE)`
   - ANI 恢復 `idle` 動畫
   - MOV 恢復正常行為

### 6.7.2 案例二：ON_CALL 文字輸入完整週期

**場景**：使用者使用 ON_CALL 快速輸入待辦事項

**完整流程**：

1. **啟動 ON_CALL**：
   - 使用者點擊 Access Widget 的 ON_CALL 按鈕
   - ON_CALL Manager 檢測到文字輸入模式
   - 彈出 Input Dialog (`InputDialog` 視窗)
2. **前端準備**：
   - Frontend Bridge 發布 `ANIMATION_CHANGED(animation=notice)`
   - ANI 播放提示動畫（閃爍、注目等）
   - MOV 切換至 FOCUSED 行為（固定位置）
3. **使用者輸入**：
   - 在 Input Dialog 輸入：「提醒我下午三點開會」
   - 點擊「送出」按鈕
4. **文本注入**：
   - Input Dialog 呼叫 `on_call_manager.submit_text(text)`
   - ON_CALL Manager 呼叫 Frontend Bridge 的 `inject_text_input()`
   - Frontend Bridge 將文字包裝為 `STTOutput` 格式
   - 直接送入 NLP 模組處理（跳過 STT）
5. **後端處理**：
   - NLP 分析意圖 → `CREATE_TODO`
   - 創建 Workflow Session
   - SYS 執行 CREATE_TODO 工作流
   - 新增待辦至系統
   - LLM 生成確認訊息：「已為您設定下午三點的開會提醒。」
6. **TTS 播放**：
   - TTS 播放確認訊息
   - ANI 播放口型動畫
7. **ON_CALL 結束**：
   - 工作流完成
   - ON_CALL Manager 關閉 Input Dialog
   - 清除 activation_flag
   - ANI 恢復 `idle` 動畫
   - MOV 恢復正常行為模擬
8. **Monitor Panel 更新**：
   - Monitor Panel 訂閱 `WORKFLOW_COMPLETED` 事件
   - 刷新待辦事項列表
   - 顯示新增的「下午三點開會」

### 6.7.3 案例三：睡眠/喚醒完整週期

**場景**：系統自動進入睡眠並被使用者喚醒

**完整流程**：

#### 進入睡眠階段

1. **觸發條件**：State Manager 檢測到 30 分鐘無活動
2. **睡眠檢查**：
   - 確認無活動 General Session
   - 確認無背景任務執行
   - 確認無工作流待處理
3. **發布睡眠事件**：
   - State Manager 發布 `SLEEP_STARTED` 事件
   - 在狀態佇列中加入 SLEEP 狀態
4. **前端響應**：
   - Frontend Bridge 接收事件
   - ANI 播放 `g_to_s` 動畫（漸漸閉眼、躺下）
   - MOV 停止所有移動模擬
   - UI 主視窗淡出（降低不透明度至 50%）
5. **後端模組卸載**：
   - Module Coordinator 依序卸載：TTS → SYS → LLM → MEM → NLP → STT
   - 保存當前狀態快照至 `memory/sleep_snapshot.json`
   - 釋放記憶體資源（關閉 FAISS 索引、清空快取）
6. **睡眠狀態維持**：
   - 前端模組**不卸載**，繼續運作
   - ANI 播放 `sleep_idle` 動畫（緩慢呼吸）
   - MOV 完全靜止
   - UI 持續監聽使用者輸入
   - Access Widget 顯示「休眠中」狀態

#### 喚醒階段

1. **喚醒觸發**：
   - 使用者點擊 Access Widget 的睡眠切換按鈕
   - 或 VAD 檢測到語音輸入
2. **發布喚醒請求**：
   - UI 模組發布 `WAKE_REQUEST` 事件到後端
   - State Manager 接收事件
3. **前端準備**：
   - ANI 播放 `waking_up` 動畫（睜眼、起身）
   - UI 主視窗淡入（恢復 100% 不透明度）
   - Monitor Panel 顯示「正在喚醒...」
4. **後端模組重載**：
   - Module Coordinator 並行重載所有模組
   - 載入順序：STT → NLP → MEM → LLM → SYS → TTS
   - MEM 從快照恢復 FAISS 索引
   - LLM 重新建立 Gemini API 連線
5. **重載完成確認**：
   - 所有模組健康檢查通過
   - State Manager 發布 `WAKE_READY` 事件
6. **前端恢復**：
   - Frontend Bridge 接收 `WAKE_READY`
   - ANI 播放 `s_to_g` 動畫（完全清醒）
   - MOV 恢復物理模擬
   - State Manager 移除 SLEEP 狀態，恢復 IDLE
7. **處理待處理輸入**：
   - 若喚醒觸發來源是語音輸入
   - 該輸入在模組重載完成後開始處理
   - 正常進入 CHAT 或 WORK 流程

**效能指標**：
- **預期喚醒時間**：3 秒內（並行重載優化）
- **記憶體釋放**：睡眠期間釋放約 50% 記憶體
- **狀態恢復完整性**：100%（無資料遺失）

---

## 6.8 技術細節與最佳實踐

### 6.8.1 前端性能優化

#### UI 模組
- **60 FPS 刷新率**：使用 QTimer 確保動畫流暢
- **無邊框視窗優化**：減少系統 UI 渲染負擔
- **事件節流**：滑鼠移動事件每 16ms 處理一次（避免過度刷新）

#### MOV 模組
- **物理模擬**：使用簡化的歐拉積分，降低計算複雜度
- **行為快取**：預計算常用移動路徑，避免即時計算
- **邊界檢測優化**：僅在接近螢幕邊緣時啟用精確碰撞檢測

#### ANI 模組
- **Transform 快取**：預先計算縮放與偏移矩陣
- **Frame Cache**：將解碼後的圖像快取在記憶體
- **Cooldown 機制**：防止高頻動畫切換（250ms 最小間隔）

### 6.8.2 前後端解耦設計

#### 事件系統分離
- **前端事件**：同步執行，專注於 UI 即時更新
- **後端事件**：異步執行，處理複雜業務邏輯
- **轉換層**：Frontend Bridge 負責事件格式轉換，避免直接耦合

#### 模組獨立性
- **UI/MOV/ANI** 可獨立運作（協調器模式）
- **後端模組** 可在無前端情況下執行（CLI 模式）
- **測試友好**：前後端可分別測試

### 6.8.3 配置驅動架構

#### 動畫配置
- **YAML 定義**：`modules/ani_module/config/animations.yaml`
- **無需修改程式碼**：新增動畫只需編輯 YAML
- **Alias 系統**：MOV 使用語義化名稱（如 `walk_left`），ANI 映射至實際檔案

#### 使用者設定
- **分層配置**：系統預設 → 使用者自訂 → 執行時覆蓋
- **類型安全**：Pydantic 驗證所有設定值
- **即時生效**：熱重載機制，無需重啟

---

## 6.9 展示層架構總結

### 6.9.1 核心成就

Phase 3 展示層實現了以下關鍵目標：

1. **統一前端管理**：Frontend Bridge 實現三大模組生命週期統一控制
2. **事件驅動協作**：前端獨立事件系統與後端解耦，提升性能
3. **使用者工具完整性**：三視窗（設定/狀態/監控）+ 快速動作提供全方位控制
4. **無縫狀態同步**：前後端狀態即時同步，動畫與系統行為一致
5. **ON_CALL 快速互動**：VAD/文字雙模式，提升使用者體驗

### 6.9.2 架構優勢

**解耦性**：
- 前端可獨立測試與展示
- 後端可無 UI 運行（伺服器模式）
- 模組間透過事件通訊，低耦合

**可擴展性**：
- 新增動畫：編輯 YAML 即可
- 新增使用者設定：修改 Settings Panel UI 與 UserSettingsManager
- 新增前端模組：實作標準介面並註冊至 Frontend Bridge

**性能**：
- 前端事件同步執行，60 FPS 流暢動畫
- 後端事件異步處理，不阻塞 UI
- 物理模擬與動畫快取優化

### 6.9.3 未來展望

**待完成功能**（Phase 4 規劃）：
- TTS 語音播放時的口型同步動畫
- 工作流進度視覺化指示器
- 多螢幕支援與視窗吸附
- 自訂主題系統（使用者可更換動畫資源）

**潛在優化**：
- GPU 加速動畫渲染（當前為 CPU）
- WebSocket 遠端控制介面
- 行動裝置配套 APP（遠端呼叫 UEP）

---

**最後更新**：2025-12-21  
**維護者**：Bernie  
**相關文檔**：
- [第五章：模組設計 - 輸出層](./05_模組設計_輸出層.md) - UI/MOV/ANI 模組詳細設計
- [第七章：系統流程](./07_系統流程.md) - 完整系統流程與會話管理
- [前後端整合需求規格](../hidden_docs/前後端整合-需求規格.md) - Phase 3 需求文檔
- [ON_CALL 實現文檔](../hidden_docs/ON_CALL_IMPLEMENTATION.md) - ON_CALL 技術細節
